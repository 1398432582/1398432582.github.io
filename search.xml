<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有关线程的理解</title>
      <link href="/2019/05/23/the-understanding-about-thread/"/>
      <url>/2019/05/23/the-understanding-about-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h2><p>在线代操作系统中，进程支持多线程。在现代操作系统中，进程支持多线程。<br>进程是资源管理的最小单元；而线程是程序执行的最小单元。</p><p>一个进程的组成实体可以分为两大部分：线程集和资源集。进程中的线程是动态的对象，代表了进程指令的执行。资源——包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。</p><p>线程有自己的私有数据：程序计数器，栈空间以及寄存器。</p><h2 id="为什么要使用线程？"><a href="#为什么要使用线程？" class="headerlink" title="为什么要使用线程？"></a>为什么要使用线程？</h2><h3 id="传统单线程进程的缺点"><a href="#传统单线程进程的缺点" class="headerlink" title="传统单线程进程的缺点"></a>传统单线程进程的缺点</h3><ol><li><p>现实中有很多需要并发处理的任务，如数据库的服务器端、网络服务器、大容量计算等。</p></li><li><p>传统的UNIX进程是单线程的，单线程意味着程序必须是顺序执行，不能并发；既在一个时刻只能运行在一个处理器上，因此不能充分利用多处理器框架的计算机。</p></li><li><p>如果采用多进程的方法，则有如下问题：</p><ul><li>fork一个子进程的消耗是很大的，fork是一个昂贵的系统调用，即使使用现代的写时复制(copy-on-write)技术。</li><li>各个进程拥有自己独立的地址空间，进程间的协作需要复杂的IPC（Inter-Process Communication，进程间通信）技术，如消息传递和共享内存等。</li></ul></li></ol><h3 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h3><p>多线程的优点和缺点实际上是对立统一的。</p><p>支持多线程的程序(进程)可以取得真正的并行(parallelism)，且由于共享进程的代码和全局数据，故线程间的通信是方便的。它的缺点也是由于线程共享进程的地址空间，可能会导致竞争，因此对某一块有多个线程要访问的数据需要一些同步技术。</p><h2 id="三种线程——内核线程、轻量级进程、用户线程"><a href="#三种线程——内核线程、轻量级进程、用户线程" class="headerlink" title="三种线程——内核线程、轻量级进程、用户线程"></a>三种线程——内核线程、轻量级进程、用户线程</h2><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel)。</p><p>内核线程只运行在内核态，不受用户态上下文的拖累。</p><ul><li>处理器竞争：可以在全系统范围内竞争处理器资源</li><li>使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间</li><li>调度：调度的开销可能和进程自身差不多昂贵</li></ul><h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p>轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。每一个进程有一个或多个LWPs，每个LWP由一个内核线程支持。这种模型实际上就是恐龙书上所提到的一对一线程模型。在这种实现的操作系统中，LWP就是用户线程。</p><p>与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息</p><ul><li>处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源</li><li>使用资源：与父进程共享进程地址空间</li><li>调度：像普通进程一样调度</li></ul><p>由于每个LWP都与一个特定的内核线程关联，因此每个LWP都是一个独立的线程调度单元。即使有一个LWP在系统调用中阻塞，也不会影响整个进程的执行。</p><p>轻量级进程具有局限性</p><ul><li>首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高——需要在user mode和kernel mode中切换。</li><li>其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间），所以一个系统不能支持大量的LWP。</li></ul><p><img src="/2019/05/23/the-understanding-about-thread/LWP.jpg" alt="LWP"></p><blockquote><p>注:<br>1.LWP的术语是借自于SVR4/MP和Solaris 2.x<br>2.有些系统将LWP称为虚拟处理器<br>3.将之称为轻量级进程的原因可能是：在内核线程的支持下，LWP是独立的调度单元，就像普通的进程一样。所以LWP的最大特点还是每个LWP都有一个内核线程支持</p></blockquote><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</p><ul><li>处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。</li><li>使用资源：与所属进程共享进程地址空间和系统资源。</li><li>调度：由在用户空间实现的线程库，在所属进程内进行调度</li></ul><p><img src="/2019/05/23/the-understanding-about-thread/Uthread1.jpg" alt="Uthread1"></p><p>上图是最初的一个用户线程模型，从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。</p><p>用户线程之间的调度由在用户空间的线程库实现。</p><p>这种模型对应着恐龙书中提到的多对一线程模型，其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。</p><h2 id="加强版用户线程——用户线程-LWP"><a href="#加强版用户线程——用户线程-LWP" class="headerlink" title="加强版用户线程——用户线程+LWP"></a>加强版用户线程——用户线程+LWP</h2><p>这种模型对应着恐龙书中多对多模型。</p><p>用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，所以可以建立任意多需要的用户线程。</p><p>操作系统提供了LWP作为用户线程和内核线程之间的桥梁。LWP还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过LWP，因此进程中某个用户线程的阻塞不会影响整个进程的执行。</p><p>用户线程库将建立的用户线程关联到LWP上，LWP与用户线程的数量不一定一致。当内核调度到某个LWP上时，此时与该LWP关联的用户线程就被执行。</p><p><img src="/2019/05/23/the-understanding-about-thread/Uthread2.jpg" alt="Uthread2"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>很多文献中都认为轻量级进程就是线程，实际上这种说法并不完全正确，从前面的分析中可以看到，只有在用户线程完全由轻量级进程构成时，才可以说轻量级进程就是线程。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式30分钟入门教程</title>
      <link href="/2019/05/22/learn-regular-expression-in-30-minutes/"/>
      <url>/2019/05/22/learn-regular-expression-in-30-minutes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://deerchao.net/tutorials/regex/common.htm" target="_blank" rel="noopener">常用正则表达式</a> | <a href="https://deerchao.net/tools/regester/index.htm" target="_blank" rel="noopener">正则表达式测试工具</a></p><hr><p>转自<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">HERE</a></p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><hr><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p><h2 id="如何使用本教程"><a href="#如何使用本教程" class="headerlink" title="如何使用本教程"></a>如何使用本教程</h2><hr><p>最重要的是——请给我<em>30分钟</em>，如果你没有使用正则表达式的经验，请不要试图在30_秒_内入门——除非你是超人 :)</p><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。</p><p>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？</p><h2 id="正则表达式到底是什么东西？"><a href="#正则表达式到底是什么东西？" class="headerlink" title="正则表达式到底是什么东西？"></a>正则表达式到底是什么东西？</h2><hr><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><p>很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是*和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><hr><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。</p><p>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。</p><p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。</p><p>不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。</p><p>\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p><p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。</p><p>这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p><p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p><p>0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p><p>这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。</p><p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。</p><h2 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h2><hr><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。</p><p>不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 <a href="https://deerchao.net/tools/regester/index.htm" title="转到Regester页面" target="_blank" rel="noopener">Regester</a>。请参考该页面的说明来安装和运行该软件。</p><p>下面是Regester运行时的截图：</p><p><a href="http://deerchao.net/tools/regester/index.htm" target="_blank" rel="noopener"><img src="/2019/05/22/learn-regular-expression-in-30-minutes/zh.png" alt="正则表达式测试器运行截图"></a></p><p>其它可用的测试工具:</p><ul><li><a href="http://www.regexbuddy.com/" target="_blank" rel="noopener">RegexBuddy</a></li><li><a href="http://regexpal.com/" target="_blank" rel="noopener">Javascript正则表达式在线测试工具</a></li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><hr><p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p><p>下面来看看更多的例子：</p><p>\ba\w<em>\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w</em>)，最后是单词结束处(\b)。</p><p>\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p><p>\b\w{6}\b 匹配刚好6个字符的单词。</p><h3 id="表1-常用的元字符"><a href="#表1-常用的元字符" class="headerlink" title="表1.常用的元字符"></a>表1.常用的元字符</h3><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。</p><p>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p><p>因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p><p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><hr><p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\.</p><p>例如：deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows。</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><hr><p>(adsbygoogle = window.adsbygoogle || []).push({});</p><p>你已经看过了前面的<em>,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如</em>,{5,12}等)：</p><h3 id="表2-常用的限定符"><a href="#表2-常用的限定符" class="headerlink" title="表2.常用的限定符"></a>表2.常用的限定符</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><p>下面是一些使用重复的例子：</p><p>Windows\d+匹配Windows后面跟1个或更多数字</p><p>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><hr><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p><p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p><p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。</p><p>下面是一个更复杂的表达式：\(?0\d{2}[) -]?\d{8}。</p><p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p><h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><hr><p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p><p>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p><p>\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p><p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><hr><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p><p>(\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p><p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p><p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><hr><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p><h3 id="表3-常用的反义代码"><a href="#表3-常用的反义代码" class="headerlink" title="表3.常用的反义代码"></a>表3.常用的反义代码</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><p>例子：\S+匹配不包含空白符的字符串。</p><p>\&lt;a[^&gt;]+>匹配用尖括号括起来的以a开头的字符串。</p><h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><hr><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：</p><p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。</p><p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\&lt;Word>\w+)(或者把尖括号换成\’也行：(?\’Word\’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<word>,所以上一个例子也可以写成这样：\b(?<word>\w+)\b\s+\k<word>\b。</word></word></word></p><p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p><h3 id="表4-常用分组语法"><a href="#表4-常用分组语法" class="headerlink" title="表4.常用分组语法"></a>表4.常用分组语法</h3><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td><td></td></tr><tr><td>捕获</td><td>(?\&lt;name>exp)</td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td>捕获</td><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td><td></td></tr><tr><td>零宽断言</td><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td><td></td></tr><tr><td>零宽断言</td><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td><td></td></tr><tr><td></td><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td><td></td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p><p>呃……其实,组号分配还不像我刚说得那么简单：</p><ul><li>分组0对应整个正则表达式</li><li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li><li>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li></ul><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><hr><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><p>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。</p><p>下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><hr><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p><p>\b\w*q[^u]\w*\b匹配包含<strong>后面不是字母u的字母q</strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w<em>\b将会匹配下一个单词，于是\b\w\</em>q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不<strong>消费</strong>任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。</p><p>零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p><p>同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。</p><p>一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).<em>(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是\&lt;b>)，然后是.\</em>(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是\&lt;b>的话，后缀就是\&lt;/b>了。整个表达式匹配的是\&lt;b>和\&lt;/b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。</p><p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p><pre><code>      (?&lt;=     # 断言要匹配的文本的前缀      &lt;(\w+)&gt;  # 查找尖括号括起来的字母或数字(即HTML/XML标签)      )        # 前缀结束      .\*      # 匹配任意文本      (?=      # 断言要匹配的文本的后缀      &lt;\/\1&gt;   # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签      )        # 后缀结束</code></pre><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><hr><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</p><p>有时，我们更需要懒惰匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><p>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p><p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p><h3 id="表5-懒惰限定符"><a href="#表5-懒惰限定符" class="headerlink" title="表5.懒惰限定符"></a>表5.懒惰限定符</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><hr><p>在C#中，你可以使用<a href="http://msdn2.microsoft.com/zh-cn/library/h5845fdz.aspx" title="MSDN 相关文档" target="_blank" rel="noopener">Regex(String, RegexOptions)构造函数</a>来设置正则表达式的处理选项。如：Regex regex = new Regex(@”\ba\w{6}\b”, RegexOptions.IgnoreCase);</p><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p><h3 id="表6-常用的处理选项"><a href="#表6-常用的处理选项" class="headerlink" title="表6.常用的处理选项"></a>表6.常用的处理选项</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>IgnoreCase(忽略大小写)</td><td>匹配时不区分大小写。</td></tr><tr><td>Multiline(多行模式)</td><td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</td></tr><tr><td>Singleline(单行模式)</td><td>更改.的含义，使它与每一个字符匹配（包括换行符\n）。</td></tr><tr><td>IgnorePatternWhitespace(忽略空白)</td><td>忽略表达式中的非转义空白并启用由#标记的注释。</td></tr><tr><td>ExplicitCapture(显式捕获)</td><td>仅捕获已被显式命名的组。</td></tr></tbody></table><p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。</p><h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><hr><p>这里介绍的平衡组语法是由 .Net Framework 支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p><p>为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx \&lt;aa \&lt;bbb> \&lt;bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p><p>这里需要用到以下的语法构造：</p><ul><li>(?’group’) 把捕获的内容命名为group,并压入堆栈(Stack)</li><li>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li><li>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li><li>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li></ul><p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p><pre><code>&lt;                         #最外层的左括号      [^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容      (        (            (?&#39;Open&#39;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot;              [^&lt;&gt;]*        #匹配左括号后面的不是括号的内容          )+        (            (?&#39;-Open&#39;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot;              [^&lt;&gt;]*        #匹配右括号后面不是括号的内容          )+    )*    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；如果还有，则匹配失败  &gt;                         #最外层的右括号  </code></pre><p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的\&lt;div>标签：\&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?’Open’&lt;div[^&gt;]*>)[^&lt;&gt;]*)+((?’-Open’\&lt;/div>)[^&lt;&gt;]*)+)*(?(Open)(?!))\&lt;/div>.</p><h2 id="还有些什么东西没提到"><a href="#还有些什么东西没提到" class="headerlink" title="还有些什么东西没提到"></a>还有些什么东西没提到</h2><hr><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看<a href="http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx" target="_blank" rel="noopener">关于正则表达式语言元素的MSDN在线文档</a>。</p><p>(adsbygoogle = window.adsbygoogle || []).push({});</p><h3 id="表7-尚未详细讨论的语法"><a href="#表7-尚未详细讨论的语法" class="headerlink" title="表7.尚未详细讨论的语法"></a>表7.尚未详细讨论的语法</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\a</td><td>报警字符(打印它的效果是电脑嘀一声)</td></tr><tr><td>\b</td><td>通常是单词分界位置，但如果在字符类里使用代表退格</td></tr><tr><td>\t</td><td>制表符，Tab</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\v</td><td>竖向制表符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\e</td><td>Escape</td></tr><tr><td>\0nn</td><td>ASCII代码中八进制代码为nn的字符</td></tr><tr><td>\xnn</td><td>ASCII代码中十六进制代码为nn的字符</td></tr><tr><td>\unnnn</td><td>Unicode代码中十六进制代码为nnnn的字符</td></tr><tr><td>\cN</td><td>ASCII控制字符。比如\cC代表Ctrl+C</td></tr><tr><td>\A</td><td>字符串开头(类似^，但不受处理多行选项的影响)</td></tr><tr><td>\Z</td><td>字符串结尾或行尾(不受处理多行选项的影响)</td></tr><tr><td>\z</td><td>字符串结尾(类似$，但不受处理多行选项的影响)</td></tr><tr><td>\G</td><td>当前搜索的开头</td></tr><tr><td>\p{name}</td><td>Unicode中命名为name的字符类，例如\p{IsGreek}</td></tr><tr><td>(?&gt;exp)</td><td>贪婪子表达式</td></tr><tr><td>(?\&lt;x>-<y>exp)</y></td><td>平衡组</td></tr><tr><td>(?im-nsx:exp)</td><td>在子表达式exp中改变处理选项</td></tr><tr><td>(?im-nsx)</td><td>为表达式后面的部分改变处理选项</td></tr><tr><td>(?(exp)yes丨no)</td><td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td></tr><tr><td>(?(exp)yes)</td><td>同上，只是使用空表达式作为no</td></tr><tr><td>(?(name)yes丨no)</td><td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td></tr><tr><td>(?(name)yes)</td><td>同上，只是使用空表达式作为no</td></tr></tbody></table><h2 id="网上的资源及本文参考文献"><a href="#网上的资源及本文参考文献" class="headerlink" title="网上的资源及本文参考文献"></a>网上的资源及本文参考文献</h2><hr><ul><li><a href="https://item.jd.com/11070361.html" target="_blank" rel="noopener">精通正则表达式(第3版)</a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/hs600312.aspx" target="_blank" rel="noopener">微软的正则表达式教程</a></li><li><a href="http://msdn2.microsoft.com/zh-cn/library/system.text.regularexpressions.regex.aspx" target="_blank" rel="noopener">System.Text.RegularExpressions.Regex类(MSDN)</a></li><li><a href="http://www.regular-expressions.info/" target="_blank" rel="noopener">专业的正则表达式教学网站(英文)</a></li><li><a href="http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx" target="_blank" rel="noopener">关于.Net下的平衡组的详细讨论（英文）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regular expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30天自制操作系统</title>
      <link href="/2019/05/21/30days-make-os/"/>
      <url>/2019/05/21/30days-make-os/</url>
      
        <content type="html"><![CDATA[<h2 id="第0天"><a href="#第0天" class="headerlink" title="第0天"></a>第0天</h2><p>　　这一天的内容主要是作者对于写书动机、如何开发操作系统以及接下来30天要做的内容的介绍，作者的风格是大致讲解基础概念，直接上手开发，先做出demo来，然后逐步添加功能，在开发中理解概念，从错误中学习经验。</p><h2 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h2><ul><li>使用BZ（二进制编辑器）制作软盘映像文件，一开始跟着作者在BZ里输入代码，结果发现书里的代码不全。所以，只能直接从光盘内容里复制粘贴。在cmd界面，输入“run”指令，“操作系统”会在QEMU中运行，可以看到如下界面</li></ul><p><img src="/2019/05/21/30days-make-os/helloos0.png" alt></p><ul><li>作者开发了一个汇编语言编译器“nask”，通过汇编重写上节的代码，再进行加工润色，加上注释等。通过nask.exe将nas文件转化为img文件，即可通过上节的方法启动操作系统。</li></ul><blockquote><p>一些缩写及解释<br>DB: define byte<br>DW: define word<br>DD: define double-word<br>RESB: reserve byte<br>$: 当前行的字节数</p></blockquote><h2 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h2><ul><li>对汇编代码的功能解释，即调用显卡在屏幕上输出字符。</li></ul><blockquote><p>汇编指令<br>  ORG origin 指定程序的装载地址<br>  JMP jump 跳转<br>  “entry:” 标号，代表地址<br>  MOV move 传送字或字节<br>  ADD add 加法<br>  CMP compare 比较<br>  JE jump if equal 等于转移<br>  INT interrupt 中断  利用INT可以调用BIOS中的函数<br>  HLT halt CPU睡眠</p></blockquote><blockquote><p>寄存器称及作用解释<br>  AX: accumulator 累加寄存器<br>  CX: counter 计数寄存器<br>  DX: data  数据寄存器<br>  BX: base 基址寄存器<br>  SP: stack pointer 栈指针寄存器<br>  BP: base pointer 基址指针寄存器<br>  SI: source index 源变址寄存器<br>  DI: destination index 目的变址寄存器<br>  AL: accumulator low 累加寄存器低位<br>  CL: counter low 计数寄存器低位<br>  DL: data low 数据寄存器低位<br>  BL: base low 基址寄存器低位<br>  AH: accumulator high 累加寄存器高位<br>  CH: counter high 计数寄存器高位<br>  DH: data high 数据寄存器高位<br>  BH: base high 基址寄存器高位<br>  EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI分别是是AX, CX, DX, BX, SP, BP, SI, DI的扩展，低16位即为对应寄存器<br>  ES: extra segment 附加段寄存器<br>  CS: code segment 代码段寄存器<br>  SS: stack segment 栈段寄存器<br>  DS: data segment 数据段寄存器<br>  FS: segment part 2 没有名称 （extra segment 附加段寄存器）<br>  GS: segment part 3 没有名称 （extra segment 附加段寄存器）</p></blockquote><ul><li>版本变为helloos04，利用原有代码删除启动区以外部分，制作512字节的启动区ipl。利用磁盘映像管理工具eding.exe在空白的磁盘映像文件写入ipl.bin的内容。</li><li>版本进入helloos05，利用Makefile替代批处理文件，Makefile比批处理文件更加智能，它能根据情况判断需要执行的指令，避免了每次需要重新生成已有的文件。这样内容得到了精简，功能反而更强大了，不过遗憾的是作者对Makefile和make.bat中的一些命令并未加以解释。</li></ul><h2 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h2><ul><li><p>由于操作系统过于简陋，名称被作者改为“harrib”(纸娃娃)，然后添加了汇编语言编写的读盘程序。将从软盘读取的数据填满了内存0x08200 ~ 0x34fff的地方，至此启动区的制作完成。</p><blockquote><p>新增汇编指令<br>  JC: jump if carry 有进位转移<br>  JNC: jump if not carry 无进位转移<br>  JAE: jump if above or equal 大于等于时转移<br>  JBE: jump if below or equal 小于等于时转移<br>  JB: jump if below 小于时转移<br>  EQU: equal 类似于C语言的#define<br>  RET: return 返回</p></blockquote><ul><li>作者写了以一个非常简短的“操作系统”只有以下三行代码</li></ul><pre><code>fin:    HLT    JMP fin</code></pre><p>用nask编译生成haribote.sys，然后利用edimg将其保存到磁盘映像里。使用BZ查看haribote.sys和haribote.img,可以发现</p><blockquote></blockquote><ol><li>文件名会写在0x002600以后的地方</li><li>文件的内容会写在0x004200以后的地方</li></ol><ul><li><p>在进行到harib00g的时候发现错误，由于之前编写读取磁盘的代码时未将<code>JNC fin</code>改为<code>JNC next</code>，故运行时并不会出现全黑画面，经过与作者代码对比改正。</p></li><li><p>切换到32位模式就无法调用BIOS功能，所以切换之前，需要修改haribote.nas,记录画面模式，取得键盘信息。</p></li><li>切换到32位模式，开始使用C语言进行编程。为了实现C语言程序调用，作者在haribote.nas中添加了100行左右的汇编代码同时将其改名为asmhead.nas，不过由于程序很复杂作者会在后面的内容中在对其进行讲解。下面是作者在第三天编写的bootpack.c</li></ul><pre><code class="cpp">void io_hlt(void);void HariMain(void){fin:      io_hlt();      goto fin;}</code></pre><blockquote><p>由bootpack生成机器语言的过程</p><ol><li>使用cc1.exe从bootpack.c生成bootpack.gas。</li><li>使用gas2nask.exe从bootpack.gas生成bootpack.nas。</li><li>使用nask.exe从bootpack.nas生成bootpack.obj。</li><li>使用obi2bim.exe从bootpack.obj生成bootpack.bim。</li><li>使用bim2hrb.exe从bootpack.bim生成bootpack.hrb。</li><li>这样就做成了机器语言，再使用copy指令将asmhead.bin与bootpack.hrb单纯结合到起来，就成了haribote.sys。</li></ol></blockquote></li><li><p>为了让计算机处于HALT状态，作者用汇编语言写了io_hlt函数。至此，第三天结束。</p></li></ul><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><ul><li>向naskfun.nas中添加write_mem8函数，使得能够在C语言中使用此函数来向内存中的指定地址写入数据。在与C语言联合使用时，只有<code>EAX</code>,<code>ECX</code>,<code>EDX</code>三个寄存器可以自由使用。通过向VRAM中写入数据，可以显示出条纹图案来。这段代码中还增加了<code>INSTRSET</code>指令，是用来告诉nask这个程序是给486使用的。</li><li><p>下一节里，作者讲解了C语言中指针的多种用法来取代write_mem函数。</p><blockquote></blockquote><p>char <em>p  用于BYTE类地址<br>short </em>p 用于WORD类地址<br>int *p   用于DWORD类地址</p></li><li><p>以下三种写法等价</p><pre><code class="c">for (i = 0xa0000; i &lt;= 0xaffff; i++) {    p = (char *)i;    *p = i &amp; 0x0f;}</code></pre><pre><code class="c">p = (char *) 0xa0000;for (i = 0; i &lt;= 0xaffff; i++) {    *(p + i) = i &amp; 0x0f;}</code></pre><pre><code class="c">p = (char *) 0xa0000;for (i = 0; i &lt;= 0xffff; i++) {    p[i] = i &amp; 0x0f;}</code></pre><p><strong>小Tips</strong>：加法运算可以交换顺序，于是(p+i)和(i+p)，p[i]和i[p]，a[2]和2[a]都是一个意思，这更能说明它们与数组没有关系。</p></li><li><p>在给颜色编号时，作者使用加了static的数组声明来节省赋值语句花费的空间<br><strong>情况一</strong></p><pre><code class="c">char a[3];a[0] = 1;a[1] = 2;a[2] = 3;</code></pre><p>翻译成汇编如下：</p><pre><code class="x86asm">a:  RESB 3  之后是赋值语句</code></pre><p><strong>情况二</strong></p><pre><code class="c">static char a[3] = {0x01, 0x02, 0x03};</code></pre><p>翻译成汇编如下:</p><pre><code class="x86asm">a:  DB 0x01, 0x02, 0x03</code></pre></li><li><p>io_out8函数可向设备中发送信号，使用此函数设定调色板。设定调色板时，需要先屏蔽中断，再恢复中断。</p><blockquote><p>CLI clear interrupt 清中断允许位<br>STI set interrupt 置中断允许位</p></blockquote></li><li><p>此处介绍了<code>EFLAGS</code>寄存器<br><img src="/2019/05/21/30days-make-os/eflags.png" alt><br>利用io_load_eflags函数保存eflags的值, 处理结束后再调用io_store_eflags恢复。不过CPU中没有<code>MOV EAX, EFLAGS</code>之类的指令，能够用来读写EFLAGS的只有 <strong>PUSHFD（push flags double-word，将标志位的值按双字压入栈）</strong> 和 <strong>POPFD(pop flags double-word，按双字长将标志位从栈弹出)</strong>指令。因此以上两个函数的汇编代码是这样的</p><pre><code class="x86asm">_io_load_eflags:        ; int io_load_eflags(void);      PUSHFD          ; 指PUSH EFLAGS      POP     EAX      RET_io_store_eflags:       ; void io_store_eflags(int eflags);      MOV     EAX, [ESP+4]      PUSH    EAX      POPFD           ; 指POP EFLAGS      RET</code></pre><p><strong>注意</strong>：io_load_eflags的返回值从何得到？根据C语言的规约，执行RET时，EAX中的值就是返回值。</p></li><li><p>像素坐标(x,y)对应的VRAM地址按下式计算<br><code>0xa0000 + x + y * 320</code><br>根据上式我们可以在窗口320x200个像素中随意填充啦，用画矩形的函数得到的效果是这样的<br><img src="/2019/05/21/30days-make-os/rectangle.png" alt><br>最终的界面如下<br><img src="/2019/05/21/30days-make-os/final.png" alt></p></li></ul><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><ul><li>从asmhead.nas中取vram等信息，将其放到一个结构体中<pre><code class="c">struct BOOTINFO {  char cyls, leds, vmode, reserve;  short scrnx, scrny;  char *vram;};</code></pre>将显示画面背景的部分独立出来，单独做成一个函数init_screen。</li><li>导入字体数据hankaku.txt,然后用makefont.exe将此文本输出成16x256=4096字节的文件。编译后生成hankaku.bin文件，加上连接所必须的接口信息变成目标文件（由bin2obj.exe来完成），相当于以下汇编语言<pre><code class="x86asm">_hankaku:  DB 各种数据（共4096字节）</code></pre>这些操作需要在MAKEFILE中增加代码<br>在C语言中使用字体时，需要写上<code>extern char hankaku[4096];</code>，像这样在源程序之外的数据都需要加上<code>extern</code>。<blockquote><p>OSASK 的 字 体 数 据 ， 依 照 一 般 的 ASCⅡ 字 符 编 码 ， 含 有 256 个 字 符 。 A 的 字 符 编 码 是 0x41, 所以 A 的 字 体 数 据 ， 放 在 “hankaku + 0x41 <em> 16 ” 开 始 的 16 字 节 里 。 C 语 言 中 A 的 字 符 编 码 可 以 用 ’ A’ 来 表 示 ， 正 好 可 以 用 它 来 代 替 0x41 ， 所 以 也 可 以 写 成 “hankaku+’A’</em> 16 ” 。</p></blockquote></li></ul><p>显示如下<br><img src="/2019/05/21/30days-make-os/ABC123.png" alt></p><ul><li>C语言中字符串都是以0x00结尾的，所以我们可以方便的编写一个显示字符串的函数<pre><code class="c">void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s){  extern char hankaku[4096];  for(; *s != 0x00; s++) {      putfont8(vram, xsize, x, y, c, hankaku + *s * 16);      x += 8;  }  return;}</code></pre></li><li>使用<code>sprintf</code>函数输出变量的值，<code>sprintf</code>和<code>printf</code>最大的区别是在于它不是按指定格式输出，只是将输出内容作为字符串写在内存中，它在制作者的精心设计下能够不使用操作系统的任何功能，使用时需要在程序开头写上<code>#include&lt;stdio.h&gt;</code>，格式类似printf<br><img src="/2019/05/21/30days-make-os/format.png" alt></li><li>现实鼠标指针的方法，类似于显示字符。</li><li>为了让CPU动起来，我们需要GDT 和 IDT的初始化。它们都是有关CPU的设定，为了让操作系统能够使用32位模式，需要对CPU进行各种设定。<blockquote><p>GDT global (segment) descriptor table 全局段号记录表<br>GDTR global (segment) descriptor table register 全局段号记录表寄存器<br>IDT interrupt descriptor table  中断记录表</p></blockquote></li><li>因为段寄存器是16位，所以可以处理0~65535范围的数，但由于CPU设计上的问题，段寄存器的低3位不能使用。故可以定义8192个段，设定这些段需要8192x8=65536字节。这64KB被写入内存中，称为GDT，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。使用鼠标需要中断机制，为了实现中断机制，必须设定IDT，其记录了0~255的终端号码与函数调用的关系，设定方法与GDT很相似。</li></ul><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><ul><li>首先分割源文件，整理Makefile，整理头文件。</li><li><p>对第五天中naskfunc.nas新增函数的解释</p><pre><code class="x86asm">_load_gdtr:        ; void load_gdtr(int limit, int addr);      MOV        AX,[ESP+4]        ; limit      MOV        [ESP+6],AX      LGDT     [ESP+6]      RET</code></pre><p>这个函数用来将指定的段上限和地址赋值给名为GDTR的48位寄存器，其并不能用MOV来赋值，只能给它指定一个内存地址，让它从指定的地址读取6个字节，然后赋值给GDTR寄存器。</p><blockquote><p>该寄存器的低16位（即内存的最初2个字节）是段上限，它等于“GDT的有效字节数 - 1”。剩下的高32位（即剩余的4个字节），代表GDT的开始地址。在最初执行这个函数的时候，DWORD[ESP + 4]里存放的是段上限，DWORD[ESP+8]里存放的是地址。具体到实际的数值，就是0x0000ffff和0x00270000。把它们按字节写出来的话，就成了[FF FF 00 00 00 00 27 00]（要注意低位放在内存地址小的字节里 ）。为了执行LGDT，笔者希望把它们排列成[FF FF 00 00 27 00]的样子，所以就先用“MOV AX,[ESP + 4]”读取最初的0xffff，然后再写到[ESP + 6]里。这样，结果就成了[FF FF FF FF 00 00 27 00]，如果从[ESP + 6]开始读6字节的话，正好是我们想要的结果。</p></blockquote><p>dsctbl.c里的set_segmdesc函数</p><pre><code class="c">struct SEGMENT_DESCRIPTOR {short limit_low, base_low;char base_mid, access_right;char limit_high, base_high;};void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar){if (limit &gt; 0xfffff) {ar |= 0x8000; /* G_bit = 1 */limit /= 0x1000;}sd-&gt;limit_low = limit &amp; 0xffff;sd-&gt;base_low = base &amp; 0xffff;sd-&gt;base_mid = (base &gt;&gt; 16) &amp; 0xff;sd-&gt;access_right = ar &amp; 0xff;sd-&gt;limit_high = ((limit &gt;&gt; 16) &amp; 0x0f) | ((ar &gt;&gt; 8) &amp; 0xf0);sd-&gt;base_high = (base &gt;&gt; 24) &amp; 0xff;return;}</code></pre><p>这个函数是按照CPU的规格要求，将段的信息归结成8个字节写入内存。</p><p>首先是段的地址。地址用32位表示，称为段的基址（base）。在这里分为low（2字节），mid（1字节）和high（1字节）3段，合起来32位，是为了与80286时代的程序兼容才分为三段。</p><p>段上限最大4GB即32位，但只能使用20位，指定到1MB为止。为了扩大指定段的大小，段属性里设置了一个标位Gbit（G：granularity）。当这个标志位为1时，limit的单位不解释成字节（byte），而解释成页（page，4KB），这样4KBx1M=4GB。20位的段上限分别写到limit_low和limit_high里。</p><p>段属性，又称为“段的访问控制权属性”，在程序中用变量名access_right或ar来表示。因为12位段属性中的高4位放在limit_high的高4位里，所以程序里有意把ar当做如下的16位构成来处理：<br><code>xxxx0000xxxxxxxx</code>(其中x是1或1)</p><p>ar的高4位被称为“扩展访问权”，由“GD00”构成，G指G bit，D指段的模式，1时指32位模式，0是指16位模式，通常使用D=1的模式。</p><p>低8位简单介绍</p><blockquote><p>00000000 （ 0x00 ） ：未使用的记录表（descriptor table ）。<br>  10010010 （ 0x92 ） ：系统专用，可读写的段。不可执行。<br>  10011010 （ 0x9a ） ：系统专用，可执行的段。可读不可写。<br>  11110010 （ 0xf2 ） ：应用程序用，可读写的段。不可执行。<br>  11111010 （ 0xfa ） ：应用程序用，可执行的段。可读不可写。</p></blockquote><p>CPU是处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权位为0x9a的段，还是位于访问权位0xfa的段。</p></li><li><p>初始化PIC(programmable interrupt controller)。PIC是将8个中断信号集合成一个中断信号的装置，为了处理更多的中断信号增加了另一个PIC。与CPU直接相连的PIC称为主PIC（master PIC），与主PIC相连的PIC称为从PIC（slave PIC）。主PIC负责处理第0到第7号中断信号，从PIC负责处理第8到第15号中断信号。<br><img src="/2019/05/21/30days-make-os/pic.png" alt></p><pre><code class="c">void init_pic(void)/* PIC的初始化 */{io_out8(PIC0_IMR, 0xff ); /* 禁止所有中断 */io_out8(PIC1_IMR, 0xff ); /* 禁止所有中断 */io_out8(PIC0_ICW1, 0x11 ); /* 边沿触发模式（edge trigger mode） */io_out8(PIC0_ICW2, 0x20 ); /* IRQ0-7由INT20-27接收 */io_out8(PIC0_ICW3, 1 &lt;&lt; 2); /* PIC1由IRQ2连接 */io_out8(PIC0_ICW4, 0x01 ); /* 无缓冲区模式 */io_out8(PIC1_ICW1, 0x11 ); /* 边沿触发模式（edge trigger mode） */io_out8(PIC1_ICW2, 0x28 ); /* IRQ8-15由INT28-2f接收 */io_out8(PIC1_ICW3, 2 ); /* PIC1由IRQ2连接 */io_out8(PIC1_ICW4, 0x01 ); /* 无缓冲区模式 */io_out8(PIC0_IMR, 0xfb ); /* 11111011 PIC1以外全部禁止 */io_out8(PIC1_IMR, 0xff ); /* 11111111 禁止所有中断 */return;}</code></pre><p><strong>IMR（interrupt mask register）</strong>“是中断屏蔽寄存器”，8位对应8路信号，如果某一位是1则对应IRQ（interrupt request）信号被屏蔽。<strong>ICW(initial control word)</strong>是“初始化控制数据”，有4个。ICW1和ICW4与PIC主板配线方式、中断信号的电气特性有关，ICW3是有关主-从连接的设定，对主PIC而言，第几号IRQ与从PIC相连，是用8位来设定的，最多驱动8个从PIC，对从PIC而言，该从PIC与主PIC的第几号相连，用3位来设定。因此不同的操作系统可以进行独特设定的就只有ICW2了，它决定了IRQ以哪一号中断通知CPU，我们以INT 0x20~0x2f接收中断号IRQ0~15。INT 0x00~0x1f用于CPU内部自动产生的保护通知。</p></li><li>鼠标是IRQ12，键盘是IRQ1，所以编写了用于INT 0x2c和INT 0x21的中断处理程序。由于中断处理完成之后，还需要返回，即执行<code>IRETD（interrupt return DWORD）</code>指令，所以中断返回程序的正常运行还需要借助汇编语言。<pre><code class="c">/*int.c的节选*/void inthandler21(int *esp)/* 来自PS/2键盘的中断 */{struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_000000, 0, 0, 32 * 8 - 1, 15);putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, &quot;INT 21 (IRQ-1) : PS/2 keyboard&quot;);for (;;) {io_hlt();}}</code></pre><pre><code class="x86asm">; naskfunc.nas节选EXTERN _inthandler21, _inthandler2c_asm_inthandler21:PUSH ESPUSH DSPUSHADMOV EAX,ESPPUSH EAXMOV AX,SSMOV DS,AXMOV ES,AXCALL _inthandler21POP EAXPOPADPOP DSPOP ESIRETD</code></pre>其中<code>PUSHAD（push all data）</code>相当于<blockquote><p>PUSH EAX<br>PUSH ECX<br>PUSH EDX<br>PUSH EBX<br>PUSH ESP<br>PUSH EBP<br>PUSH ESI<br>PUSH EDI</p></blockquote></li></ul><p><code>POPAD（pop all data）</code>相当于相反的操作<br><code>CALL</code>是调用函数的指令</p><ul><li>最后将asm_inthandler21注册到IDT中去<pre><code class="c">/* IDT的设定 */set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);</code></pre><blockquote><p>asm_inthandler21注册在idt的第0x21号。这样，如果发生中断了，CPU就会自动调用asm_inthandler21。这里的2 * 8表示的是asm_inthandler21属于哪一个段，即段号是2，乘以8是因为低3位有着别的意思，这里低3位必须是0。</p><pre><code class="c">set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);</code></pre><p>程序中的以上语句说明号码为2的段正好涵盖了整个bootpack.hrb.<br>最后的AR_INTGATE32将IDT的属性，设定为0x008e。它表示这是用于中断处理的有效设定.</p></blockquote></li></ul><p>在HariMain的最后，修改了PIC的IMR，这样就能接受来自鼠标和键盘的中断了。</p><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><ul><li>为了获取按键编码，需要设置缓冲区。按下或松开键盘时，会产生两个中断，分别发送两个按键码。一开始，由于只设置了一个字符的缓冲区。在程序处理第一个中断时，第二个按键码就被发送了，由于还未开中断，所以第二个中断产生的按键码被丢弃。再扩大缓冲区，同时使用FIFO队列后，可以记录大量的数据，执行速度也得到了提高。</li><li>由于鼠标只要一动就会产生中断，所以主板上虽然有鼠标用的电路，但只要不执行激活鼠标的指令，就不会产生鼠标的中断信号。想要使用鼠标，要想让鼠标控制电路有效，然后再让鼠标有效。事实上，鼠标控制电路包含在键盘控制电路里，如果键盘控制电路的初始化正常完成，鼠标控制电路的激活也就完成了。键盘控制电路没有CPU电路快，所以我们需要一个<code>wait_KBC_sendready</code>函数来确认是否可以往键盘控制电路传送信息。如果键盘控制电路可以接受CPU指令了，CPU从设备号码0x0064处所得的数据的倒数第二位应该是0。将模式设置为鼠标模式后，鼠标控制电路就准备完成，然后发送鼠标激活指令，待鼠标收到指令后，就会回复信息0xfa，这样鼠标中断就可以收到了。</li><li><p>鼠标数据的取得方法与键盘完全相同，要靠中断号码来区分数据来自键盘还是鼠标。由于鼠标往往会更快地送出大量数据，所以我们将它的FIFO缓冲区增加到128字节，编译运行后，可以显示出来自键盘和鼠标的数据。</p><p>  <img src="/2019/05/21/30days-make-os/mousedata.png" alt></p></li></ul><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><ul><li><p>鼠标移动每次会产生三个字节的数据，第八天一开始的工作是将鼠标的数据构建了一个结构体，然后整理了有关代码，将数据显示在屏幕上，如下图</p><p>  <img src="/2019/05/21/30days-make-os/mousedata1.png" alt><br>第一位会在0~3的范围内变化，第二位会在点击鼠标时发生变化，三四位与鼠标的左右移动有关，五六位与鼠标的上下移动有关。</p></li><li><p>然后向鼠标结构体中增加几个变量用于存放解读结果，x，y，btn，分别用于存放移动信息和鼠标按键状态。加上了对第一字节的判断，以防止鼠标出现接触不良等情况导致数据出问题。鼠标按键的状态，存放在buf[0]的低三位。x和y的第八位及以后位全部设成1或全部都保留为0，就能正确的解读x和y。鼠标与屏幕的y方向正好相反，对y进行取反操作。通过如下代码，鼠标就能移动了</p><pre><code class="c">  } else if (fifo8_status(&amp;mousefifo) != 0) {      i = fifo8_get(&amp;mousefifo);      io_sti();      if (mouse_decode(&amp;mdec, i) != 0) {      /* 数据的3个字节都齐了，显示出来 */      sprintf(s, &quot;[lcr %4d %4d]&quot;, mdec.x, mdec.y);      if ((mdec.btn &amp; 0x01) != 0) {          s[1] = &#39;L&#39;;      }      if ((mdec.btn &amp; 0x02) != 0) {          s[3] = &#39;R&#39;;      }      if ((mdec.btn &amp; 0x04) != 0) {          s[2] = &#39;C&#39;;      }      boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);      putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 32, 16, COL8_FFFFFF, s);      /* 鼠标指针的移动 */      boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, mx, my, mx + 15, my + 15); /* 隐藏鼠标 */      mx += mdec.x;      my += mdec.y;      if (mx &lt; 0) {          mx = 0;      }      if (my &lt; 0) {          my = 0;      }      if (mx &gt; binfo-&gt;scrnx - 16) {          mx = binfo-&gt;scrnx - 16;      }      if (my &gt; binfo-&gt;scrny - 16) {          my = binfo-&gt;scrny - 16;      }      sprintf(s, &quot;(%3d, %3d)&quot;, mx, my);      boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, 0, 0, 79, 15); /* 隐藏坐标 */      putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, 0, 0, COL8_FFFFFF, s); /* 显示坐标 */      putblock8_8(binfo-&gt;vram, binfo-&gt;scrnx, 16, 16, mx, my, mcursor, 16); /* 描画鼠标 */      }  }</code></pre><p>  但这时还有一个小问题，由于没考虑到叠加处理，鼠标移动时，会将任务栏消除，这个问题会在后面解决。</p><p>  <img src="/2019/05/21/30days-make-os/mousemove.png" alt></p></li><li><p>作者终于要把前面挖的坑给填了，asmhead.nas中的代码，在此节中给出了解释。</p></li></ul><pre><code class="x86asm">; PIC关闭一切中断;   根据AT兼容机的规格，如果要初始化PIC，;   必须在CLI之前进行，否则有时会挂起，;   随后进行PIC的初始化        MOV     AL,0xff        OUT     0x21,AL        NOP                     ; 如果连续执行OUT指令，有些机种会无法正常运行        OUT     0xa1,AL        CLI                     ; 禁止CPU级别的中断</code></pre><p>上面这段汇编代码功能相当于下面的C语言代码</p><pre><code class="c">io_out8(PIC0_IMR,  0xff  ); /* 禁止主PIC的全部中断 */io_out8(PIC1_IMR,  0xff  ); /* 禁止从PIC的全部中断 */Io_cli(); /*禁止CPU级别的中断*/</code></pre><p>为了让CPU能够访问1MB以上的内存空间，设定A20GATE</p><pre><code class="x86asm">        CALL    waitkbdout        MOV     AL,0xd1        OUT     0x64,AL        CALL    waitkbdout        MOV     AL,0xdf         ; enable A20        OUT     0x60,AL        CALL    waitkbdout</code></pre><p>等同于下面的代码</p><pre><code class="c">#define KEYCMD_WRITE_OUTPORT     0xd1#define KBC_OUTPORT_A20G_ENABLE  0xdf    /* A20GATE的设定*/    Wait_KBC_sendready();    Io_out8(PORT_KEYCMD, KEYCMD_WRITE_OUTPORT);    Waite_KBC_sendready();    Io_out8(PORT_KEYDAT, KBC_OUTPORT_A20G_ENABLE);    Waite_KBC_sendready();     /*这句话是为了等待完成执行指令*/</code></pre><p>这样A20GATE信号线变成ON的状态，内存的1MB以上的部分就变成可用状态了。</p><p>接下来通过LGDT设定临时GDT，将CR0的值代入EAX切换到保护模式，这里牵扯到的CR0(control register 0)是一个特殊的寄存器，只有操作系统才能操作它</p><p><img src="/2019/05/21/30days-make-os/cr0.jpg" alt></p><p>当我们将它的最高位置为0，最低位置为1时，就进入到了不分页的保护模式。</p><p>这之后的代码基本都在执行memcpy的功能，在内存中传送各种数据，系统的内存分布图如下:</p><p><img src="/2019/05/21/30days-make-os/memdtr.png" alt></p><ul><li>这里作者讲的有点不清不楚的，有几个地方没搞懂，所以梳理了一下流程及各文件的作用，以期对内容有更深入的理解</li></ul><p><img src="/2019/05/21/30days-make-os/order.png" alt></p><p>ipl10.nas负责读盘到内存，读完盘之后跳转到0xc200处，即asmhead.nas。<br>asmhead.nas负责显示模式及分辨率设置即从16位转换为32位保护模式，是C语言和汇编语言的桥梁，执行到最后就转到bootpack.c的主函数。<br>bootpack.c包含主函数，做好初始化各种操作然后接收键盘和鼠标信息，并对信息进行解析，呈现在屏幕上，此外还有字库，鼠标显示，鼠标位置计算等等。这里用到了GDT和IDT，对消息的接收要用中断，对消息的保存要用FIFO缓冲区。<br>dsctbl.c与GDT、IDT分段及中断相关。<br>graphic.c负责设置调色板，显示字符串，绘制矩形，绘制鼠标，绘制窗口，大部分与VRAM相关的函数都在这里。<br>int.c包括一些中断处理函数，但是这些并不是中断的真正入口，真正入口是对应的汇编函数，这里的函数是对应的汇编函数要调用的。这些函数处理键盘中断和鼠标中断，为了加速处理，要把收到的数据放进FIFO缓冲区，防止因为在中断中进行大量的处理而影响速度。<br>fifo.c这是一个简单的用数组形式建立的FIFO循环链表。<br>hankaku.txt是一个字库。<br>naskfunc.nas有一些不能用C语言写的函数，必须用汇编语言，都放在这个文件里。</p><p><strong>ipl10.nas</strong></p><p>这部分主要负责先载入 启动扇区（0x7c00 ~ 0x7dff）<br>启动扇区载入完毕之后，将 IPL 软盘中除了启动扇区的那一块）载入到内存的 0x8200 ~ 0x34fff 区域（这里实际上只是载入了 10 个柱面 180KB）<br>跳转到 0xc200 处运行（这个地方实际就是 asmhead 的开始位置）</p><p><strong>asmhead.nas</strong></p><p>这部分的主要工作在之前已经提到过了<br>他将0x7c00 ~ 0x7dff 处的512byte的启动扇区数据拷贝到 0x100000 处（1MB 空间开始位置）<br>然后将 0x8200 ~ 0x34fff 处的IPL数据拷贝到 0x100200 处<br>同时将bootpack.hrb 的数据拷贝到0x280000位置处<br>最后跳转到 bootpack.hrb 处开始执行</p><p><strong>bootpack.c</strong></p><p>这部分实际就是我们 C 语言部分的操作， 用于处理键盘，鼠标中断响应， 图形绘制等操作</p><h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><ul><li>因为bootpack.c的代码又变的复杂了，再次整理代码，将设计键盘和鼠标的函数分别放到keyboard.c和mouse.c里。</li><li>进行内存管理首先要搞清楚内存有多大，需要写代码去检查内存。在检查内存的时候要先检测是否是486以后的CPU，如果是就暂时让CPU的高速缓存功能无效，否则写入和读出都是在缓存中进行的，结果所有的“内存”一切正常。可是在用如下函数去检查内存时，得到的内存容量是3072MB而不是设定的32MB</li></ul><pre><code class="c">unsigned int memtest_sub(unsigned int start, unsigned int end){    unsigned int i, *p, old, pat0= 0xaa55aa55, pat1 = 0x55aa55aa;    for(i = start; i &lt;= end; i += 0x1000) {        p = (unsigned int *) (i + 0xffc);        old = *p;  //先记住修改前的值        *p = pat0; //试写        *p ^= 0xffffffff; //反转        if (*p != pat1) { //检查反转结果not_memory:            *p = old;            break;        }        *p ^= 0xffffffff; //再次反转        if (*p != pat0) { //检查值是否恢复            goto not_memory;        }        *p = old;  //恢复为修改前的值    }    return i;}</code></pre><p>这是什么原因造成的呢？原来是由于编译器太“聪明”了，在编译时它进行了最优化处理，结果我们的代码相当于下面这样子</p><pre><code class="c">unsigned int memtest_sub(unsigned int start, unsigned int end){unsigned int i;for (i = start; i &lt;= end; i += 0x1000) { }return i;}</code></pre><p>也就是说，根本没有进行内存检查。</p><ul><li><p>如果更改编译选项，停止最优化处理，是可以解决上述问题的，但我们在其他地方还是需要最优化处理的。这时候就需要我们的好帮手汇编语言出场了，将memtest_sub函数用汇编语言改写，这次可以得出正确的结果了。</p></li><li><p>作者采用了一种列表结构去存储内存管理信息，构建可用内存空间管理表，有关功能的编写类似于链表。这种方式占用内存少，分配和释放都很迅速，虽然管理程序变复杂了，但相比于效率的提高，这是值得的。还有一个缺点是，当可用空间变得零零散散，怎么都归纳不到一块儿时，会将空间管理信息全部用完。这时就要割舍掉小块内存（本节中是割舍掉了新来的信息），为了不在这个问题上纠结太久，作者采用了一种做法，即“割舍掉的东西，只要以后还能找回来，就暂时不去管它。”，留待以后解决。  </p></li></ul><h2 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h2><ul><li>如果反复使用<code>memman_alloc</code>和<code>memman_free</code>进行以一字节为单位的内存管理，内存中就会出现很多不连续的小段未使用空间，这样就回吧man-&gt;frees耗尽。此次增加了两个以4KB为单位进行内存分配和释放的函数<code>memman_alloc_4k</code>和<code>memman_free_4k</code>来方便内存管理，使用了 <strong>i = (i + 0xfff) &amp; 0xfffff000</strong> 的巧妙方法来进行向上舍入。</li><li><p>为了实现窗口的叠加，引入了图层（sheet）的概念，通过移动图层的方法实现鼠标指针和窗口的移动。新增函数位于sheet.c中，一开始的程序中，只要有移动就会对整个画面进行重绘，这无形中增加了许多不必要的开销（可能是由于电脑性能的提高，我并未观察到作者所说的现象）。通过增加一个<code>sheet_refreshsub</code>函数，我们可以指定重绘的范围从而提高速度。</p><h2 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h2></li><li><p>修改<code>sheet_refreshsub</code>功能，让它不刷新画面外的部分，使得鼠标能够移动到画面外。</p></li><li>精简函数，省略shtctl的指定。</li><li><p>描绘出一个窗口，构建方式与之前的方法相同，关闭按钮类似于鼠标指针，边框利用<code>boxfill8</code>函数画出，文字利用<code>putfont8_asc</code>放置。效果如下<br><img src="/2019/05/21/30days-make-os/myos.png" alt></p></li><li><p>将之前的窗口改成一个计数器，但在计数器工作时，会出现闪烁的现象。这是由于在刷新的时候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，就会造成闪烁。如图<br><img src="/2019/05/21/30days-make-os/flash.png" alt><br>解决方法是仅对refresh对象及其以上的图层进行刷新，这样不仅避免了闪烁现象，还减小了刷新的开销。</p></li><li>但是我们的闪烁现象并未完全解决，将鼠标放在计数器的数字上面时，鼠标又闪烁起来了。想要解决此问题，需要在刷新窗口时避开鼠标所在的地方对VRAM进行写入处理，开辟一块内存，大小和VRAM一样，称之为map。之所以叫map是因为这块内存用来表示画面上的点是哪个图层的像素，所以它就相当于是图层的地图。<br><img src="/2019/05/21/30days-make-os/map.png" alt><br>在map写入信息，今后程序会对照map内容来向VRAM中写入。</li></ul><h2 id="第十二天"><a href="#第十二天" class="headerlink" title="第十二天"></a>第十二天</h2><ul><li>定时器对于操作系统非常重要，它的原理是每隔一段时间就发送一个中断信号给CPU，只要在中断处理程序中数一数定时器中断发生的次数就可以计算出经过了多长时间。</li><li><p>要在电脑中管理定时器，需要设定PIT（Programmable Interval Timer），PIT连接着IRQ0，所以设定了PIT就可以设定IRQ0的中断间隔。</p><blockquote><p>IRQ0的中断周期变更:<br>  AL=0x34:OUT(0x43,AL);<br>  AL=中断周期的低8位; OUT(0x40,AL);<br>  AL=中断周期的高8位; OUT(0x40,AL);<br>  到这里告一段落。<br>  如果指定中断周期为0，会被看作是指定为65536。实际的中断产生的频率是单位时间时钟周期数（即主频）/设定的数值。比如设定值如果是1000，那么中断产生的频率就是1.19318KHz。设定值是10000的话，中断产生频率就是119.318Hz。再比如设定值是11932的话，中断产生的频率大约就是100Hz了，即每10ms发生一次中断。</p></blockquote><p>  下面的C语言代码即用于进行中断周期的变更</p><pre><code class="c">  #define PIT_CTRL 0x0043  #define PIT_CNT0 0x0040  void init_pit(void)  {  io_out8(PIT_CTRL, 0x34);  io_out8(PIT_CNT0, 0x9c);  io_out8(PIT_CNT0, 0x2e);  return;  }</code></pre><p>  同时我们还需要中断处理程序:</p><pre><code class="c">  void inthandler20(int *esp)  {  io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收完了的信息通知给PIC */  /* 暂时什么也不做 */  return;  }</code></pre><pre><code class="x86asm">  _asm_inthandler20:  PUSH ES  PUSH DS  PUSHAD  MOV EAX,ESP  PUSH EAX  MOV AX,SS  MOV DS,AX  MOV ES,AX  CALL _inthandler20  POP EAX  POPAD  POP DS  POP ES  IRETD</code></pre><p>  为了把这个中断处理程序注册到IDT，init_gdtidt函数中也要加上</p><pre><code class="c">  set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);</code></pre><p>  处理方法基本与之前的键盘和鼠标中断相同。</p></li><li><p>作者定义了一个名为TIMERCTL的结构体（目测以后还会对其进行扩展），改写init_pit和inthandler20增加了计数功能，数字以每秒钟100的速度增加，效果(不过看不出)如下<br><img src="/2019/05/21/30days-make-os/counter.png" alt></p></li><li><p>果不其然现在TIMERCTL变成了如下的样子</p><pre><code class="c">  struct TIMERCTL {  unsigned int count;  unsigned int timeout;  struct FIFO8 *fifo;  unsigned char data;  };</code></pre><p>  至于为什么要这样做，是因为我们想要实现“超时”（timeout）功能。以上结构体中的timeout用来记录离超时还有多长时间，一旦这个剩余时间达到0，程序就往FIFO缓冲区里发送数据，定时器就是通过这种方法通知HariMain时间到了。<br>  写个程序试一下，在其中设定10秒钟以后向tiemerfifo写入“1”这个数据，而timerfifo收到数据时，就会在屏幕上显示“10[sec]”。<br>  <img src="/2019/05/21/30days-make-os/timeout.png" alt></p></li><li><p>操作系统中的很多地方，例如光标闪烁、时间显示等等都需要定时器，所以我们要设定多个定时器，定义如下结构体，修改相关函数</p><pre><code class="c">  #define MAX_TIMER 500  struct TIMER {  unsigned int timeout, flags;  struct FIFO8 *fifo;  unsigned char data;  };  struct TIMERCTL {  unsigned int count;  struct TIMER timer[MAX_TIMER];  };</code></pre><p>  编写程序测试一下效果，如下:<br>  <img src="/2019/05/21/30days-make-os/manycounters.png" alt></p></li><li><p>由于inthandler20花费了很长时间来进行中断处理，妨碍了其它中断处理程序的执行，使得操作系统反应迟钝，所以作者用了很大的篇幅来讲怎么对其进行优化，从而加快中断处理。</p></li></ul><h2 id="第十三天"><a href="#第十三天" class="headerlink" title="第十三天"></a>第十三天</h2><ul><li>简化字符串显示，将一些常用的功能整理为一个函数。</li><li>重新调整FIFO缓冲区，将多个定时器的缓冲区合并为一个，通过往FIFO内写入不同数据来分辨出是哪个定时器超时。</li><li><p>性能真的提高了吗？-性能测试</p><p>  设置count变量，完全不显示计数，全力执行“cout++”，通过cout的值来测试系统性能。需要注意，必须在启动3秒后把count复位为0一次。</p><blockquote><p><strong>起动 3 秒后，将 count 置为 0 的原因</strong><br>  首先考虑一下这个命令的意思吧。起动3秒后把count复位至0，这与从3秒后开始计数是一样的。画面上要到10秒以后才显示，这样测试的时间就是7秒钟。<br>  事实上，笔者最初并没有加入“count=0;”语句。但那样做的结果是，在真机上测定harib10d时，最高值和最低值的差值竟然达到了150054。这可了不得呀。差值这么大，即使我们比较harib10c和harib10d，也不知道哪个更快。<br>  对于这样的结果，笔者曾茫然不知所措，差一点要放弃性能比较。但后来笔者忽然想起，只要某些条件稍微有些变化，电脑初始化所花费的时间就会有很大变化。这就是为什么我们在起动后3秒钟之内不进行测试的原因。这样做之后，误差急剧减小，终于可以比较结果了，真是太好了。 </p></blockquote><p>  通过测试可以看出，系统的性能的确得到了提高。</p></li><li><p>再次调整FIFO缓冲区，将从键盘和鼠标输入的数据也归入计时器的FIFO中</p><blockquote><p>0～ 1 ………………… 光标闪烁用定时器<br>  3 ………………… 3秒定时器<br>  10 ………………… 10秒定时器<br>  256～ 511 ………………… 键盘输入（从键盘控制器读入的值再加上256）<br>  512～ 767 …… 鼠标输入（从键盘控制器读入的值再加上512）</p></blockquote><p>  这样用一个FIFO缓冲区就可以正常进行处理了。</p></li><li><p>加快中断处理，之前的inthandler20和timer_settime中引入了太多的移位处理，浪费时间。此次修改通过链表来管理定时器，消除了移位处理。添加“哨兵”元素，简化链表插入时的复杂情况。</p></li></ul><h2 id="第十四天"><a href="#第十四天" class="headerlink" title="第十四天"></a>第十四天</h2><ul><li><p>继续测试性能<br>  添加以下函数</p><pre><code class="c">  void set490(struct FIFO32 *fifo, int mode)  {      int i;      struct TIMER *timer;      if (mode != 0) {          for (i = 0; i &lt; 490; i++) {              timer = timer_alloc();              timer_init(timer, fifo, 1024 + i);              timer_settime(timer, 100 * 60 * 60 * 24 * 50 + i * 100);          }      }      return;  }</code></pre><p>  这样我们就设定了490个定时器。</p><blockquote><p>真机上运行结果的比较<br>  (1) 追加490个定时器时的值 set490（&amp;fifo, 1）;<br>  harib11a:0096521077 ……harib10g  里加入 set490  的时候( 有移位)<br>  harib11b:0096522038 ……harib10h  里加入 set490  的时候( 没有移位、没有哨兵)<br>  harib11c:0096522097 ……harib10i  里加入 set490  的时候( 没有移位、有哨兵)<br>  (2) 不追加490个定时器时的值 set490（&amp;fifo, 0）;<br>  harib11a:0096522095 ……harib10g  里加入 set490  的时候( 有移位)<br>  harib11b:0096522038 ……harib10h  里加入 set490  的时候( 没有移位、没有哨兵)<br>  harib11c:0096522101 ……harib10i  里加入 set490  的时候( 没有移位、有哨兵)<br>  (3) 参考：不加入set490语句时的值<br>  harib10g:0099969263 ……( 有移位)<br>  harib10h:0099969184 ……( 没有移位、没有哨兵)<br>  harib10i:0099969264 ……( 没有移位、有哨兵)  </p></blockquote><p>  这里有一个有趣的现象，对于（2)和（3），处理上虽然完全相同，而结果却相差了345万左右，原因是什么呢？</p><blockquote><p>这不是程序内容的问题，而是C编译器的问题。实际<br>  上，由于跳转目标地址不同，CPU的JMP指令执行的时钟周期数也不相同。在HariMain中，循环执行“count++；”的for语句虽然最终被编译为JMP指令执行，但如果前面加上“set490（&amp;fifo,0）；”语句，那么以后各个指令的地址也都会相应地错开几个字节，结果造成JMP指令的地址也略有变化。因此执行时间也稍稍延迟，执行结果大约变差了3%.</p><pre><code class="c">  for（;;） ｛                L2：      count++;                count++;      任意语句;          -&gt;    任意语句;  }                      JMP     L2          这个L2的地址一旦变化，JMP的执行时间就变化！</code></pre></blockquote></li><li><p>提高分辨率</p><p>  使用VBE（VESA BIOS extension）可以切换到新画面模式，切换时要用”<strong>AX = 0x4f02；BX = 画面模式号码</strong>“, VBE的的画面模式号码如下:</p><blockquote><p>0x101 ……640× 480× 8bit  彩色<br>  0x103 ……800× 600× 8bit  彩色<br>  0x105 ……1024× 768× 8bit  彩色<br>  0x107 ……1280× 1024× 8bit</p></blockquote><p>  实际指定的时候，要将以上的画面模式号码值加上0x4000，再赋值到BX中去</p><p>  如果想在真机上运行我们则需要进行一系列的检查</p><pre><code class="x86asm">  ; 确认VBE是否存在      MOV        AX,0x9000      MOV        ES,AX      MOV        DI,0      MOV        AX,0x4f00      INT        0x10      CMP        AX,0x004f      JNE        scrn320  ; 检查VBE的版本      MOV        AX,[ES:DI+4]      CMP        AX,0x0200      JB        scrn320            ; if (AX &lt; 0x0200) goto scrn320  ; 取得画面模式信息      MOV        CX,VBEMODE      MOV        AX,0x4f01      INT        0x10      CMP        AX,0x004f      JNE        scrn320  ; 画面模式信息的确认      CMP        BYTE [ES:DI+0x19],8      JNE        scrn320      CMP        BYTE [ES:DI+0x1b],4      JNE        scrn320      MOV        AX,[ES:DI+0x00]      AND        AX,0x0080      JZ        scrn320        ; 模式属性的bit7是0，所以放弃  ; 画面模式的切换      MOV        BX,VBEMODE+0x4000      MOV        AX,0x4f02      INT        0x10      MOV        BYTE [VMODE],8    ; 记录画面模式      MOV        AX,[ES:DI+0x12]      MOV        [SCRNX],AX      MOV        AX,[ES:DI+0x14]      MOV        [SCRNY],AX      MOV        EAX,[ES:DI+0x28]      MOV        [VRAM],EAX      JMP        keystatus  scrn320:      MOV        AL,0x13            ; VGA图、320x200x8bit彩色      MOV        AH,0x00      INT        0x10      MOV        BYTE [VMODE],8    ; 记录画面模式      MOV        WORD [SCRNX],320      MOV        WORD [SCRNY],200      MOV        DWORD [VRAM],0x000a0000</code></pre><blockquote><p>在画面模式信息中，重要的信息有如下6个。<br>  WORD [ES : DI+0x00] :  模式属性……bit7  不是 1  就不好办( 能加上 0x4000)<br>  WORD [ES : DI+0x12] : X  的分辨率<br>  WORD [ES : DI+0x14] : Y  的分辨率<br>  BYTE  [ES : DI+0x19] :  颜色数……必须为 8<br>  BYTE  [ES : DI+0x1b] :  颜色的指定方法……必须为 4 (4  是调色板模式)<br>  DWORD [ES : DI+0x28] : VRAM  的地址<br>  在这6项信息当中，我们来确认如下3项：<br>    颜色数是否为8<br>    是否为调色板模式<br>    画面模式号码可否加上0x4000再进行指定  </p></blockquote></li><li><p>键盘输入</p><p>  查询下面的表，表里的值是按下键时的数值，在表里数值的基础上加0x80就可以得到键弹起时的数值。<br>  <img src="/2019/05/21/30days-make-os/keyboardtable.png" alt><br>  在HariMain中添加一些代码我们甚至已经可以实现下面的效果了<br>  <img src="/2019/05/21/30days-make-os/hellobupt.png" alt></p></li><li><p>窗口移动</p><pre><code class="c">if ((mdec.btn &amp; 0x01) != 0) {/* 按下左键、移动sht_win */sheet_slide(sht_win, mx - 80, my - 8);}</code></pre><p>只用了短短几行代码我们就实现了窗口移动的功能，不过，它也有缺点，比如窗口会移动到鼠标点击的地方，而不只是拖动。</p></li></ul><h2 id="第十五天"><a href="#第十五天" class="headerlink" title="第十五天"></a>第十五天</h2><ul><li><p>任务切换，向CPU发出任务切换指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回这个程序的时候可以继续运行。为了把寄存器中的内容写入内存里去，我们需要任务状态段，即TSS（task status segment），TSS也是内存段的一种，需要在GDT中进行定义后使用</p><pre><code class="c">//TSS的结构struct TSS32 {int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;int es, cs, ss, ds, fs, gs;int ldtr, iomap;};</code></pre><p>从开头的backlink起，到cr3为止的几个成员，保存的不是寄存器的数据，而是与人物设置相关的信息，在执行任务切换的时候这些成员不会被写入（backlink除外，某些情况下是会被写入的）<br>第二行的成员是32位寄存器，第三行是16位寄存器<br>EIP用来记录下一条需要执行的指令位于内存中哪个地址，当下次再返回这个任务的时候，CPU就可以明白应该从哪里读取程序来运行了。<br>ldtr和iomap也和第一行的成员一样，是有关人物设置的部分。</p><p>JMP指令分为两种，只改写EIP的称为near模式，同时改写EIP和CS的称为far模式，在此之前我们使用的JMP指令基本上都是near模式的。下面这条之前写过的就是far模式的JMP指令</p><pre><code class="c">JMP  DWORD 2*8:0x0000001b</code></pre><p>这条指令在向EIP存入0x1b的同时，将CS置为2*8（=16）。</p><p>创建TSS，将他们加入GDT，通过编写相关函数我们就能进行任务的切换了。</p></li></ul><h2 id="第十六天"><a href="#第十六天" class="headerlink" title="第十六天"></a>第十六天</h2><ul><li><p>由于多任务是一个操作系统非常重要的一部分，所以我们继续对多任务进行优化，仿造struct SHTCTL增添了一个struct TASKCTL。</p><pre><code class="c">struct TASKCTL {  int running; /*正在运行的任务数量*/  int now; /*这个变量用来记录当前正在运行的是哪个任务*/  struct TASK *tasks[MAX_TASKS];  struct TASK tasks0[MAX_TASKS];};</code></pre><p>新增函数</p><blockquote><p>task_init: 将一个程序变成任务<br>task_alloc: 初始化一个任务结构<br>task_run: 将task添加到tasks的末尾，然后使running加一<br>task_swicth: 当running为1时，不需要进行任务切换，函数直接结束。当running大于等于2时，先把now加1，然后把now所代表的任务切换成当前任务，最后再将末尾的任务移动到开头。<br>task_sleep: 让任务休眠，如果要唤醒任务只需执行task_run。</p></blockquote></li><li><p>在任务优先级的处理上，作者使用了多级队列调度的方式，如下图<br><img src="/2019/05/21/30days-make-os/multiplequeue.png" alt><br>这样在多任务的处理上，高优先级的任务，会得到更多的资源，避免了卡顿现象<br><img src="/2019/05/21/30days-make-os/multiplewindow.png" alt></p></li></ul><h2 id="第十七天"><a href="#第十七天" class="headerlink" title="第十七天"></a>第十七天</h2><ul><li><p>在之前的多任务管理中，如果任务A下面的LEVEL中有任务B0~B2，在任务A进入休眠状态后，mtask.c将自动寻找下层LEVEL中的任务，但如果我们没有启动B0~B2，程序就找不到其他的任务而导致运行出现异常。因此我们引入了一个”idle”(闲置)任务，并把它一直放在最下层的LEVEL中，这样一来，即便任务A进入休眠状态，系统也会自动切换到这个闲置任务，问题就得到解决了。而且闲置任务也很简单，它的功能只是执行HTL，代码如下</p><pre><code class="c">void task_idle(void){  for (;;) {      io_hlt();  }}</code></pre></li><li><p>创建命令行窗口，首先做一个新的任务命名为console_task，保留原先的task_a，结果如下<br><img src="/2019/05/21/30days-make-os/console1.png" alt></p></li><li><p>上面只是做了个窗口雏形，因此我们得让它接受字符输入，现在我们输入的字符都会跑到任务A的窗口中去，为了能够往命令行窗口中输入字符，我们要让系统在按下”Tab”键的时候，将输入窗口切换到命令行窗口上去。首先实现窗口标题栏颜色的切换，效果如下<br><img src="/2019/05/21/30days-make-os/console2.png" alt></p></li><li><p>想要向console_task的FIFO发送数据，需要知道FIFO的内存地址，基本上没有什么任务是完全用不到FIFO的，因此我们在struct TASK中加入struct FIFO</p><pre><code class="c">struct TASK {  int sel, flags; /* sel代表GDT编号 */  int level, priority;  struct FIFO32 fifo; /*这里！ */  struct TSS32 tss;};</code></pre><p>功能的实现参照原先的代码，运行效果如下<br><img src="/2019/05/21/30days-make-os/console3.png" alt></p></li><li><p>经过之前的努力，我们可以输入英文、数字和符号了，但还无法输入“！”和“%”。为了能够输入这两个符号，我们必须要处理Shift键，Shift编码如下</p><p>  |       |按下|抬起|<br>  |——-|—-|—-|<br>  |左Shift|0x2a|0xaa|<br>  |右Shift|0x36|0xb6|<br>  准备一个key_shift变量，当左Shift按下时置为1，右Shift按下时置为2，两个都不按时置为0，两个都按下时置为3。使用两个不同的字符集，当key_shift为0时，我们用keytable0[]将按键编码转换为字符编码，而当key_shift不为0时，则使用keytable1[]进行转换。</p></li></ul><p>运行结果如下<br><img src="/2019/05/21/30days-make-os/console4.png" alt></p><ul><li><p>接下来要实现区分大小写字母的输入，我们要同时判断Shift键和CapsLock键的状态</p><blockquote><p>CapsLock 为 为 OFF &amp; Shift  键为 OFF  → 小写英文字母<br>  CapsLock 为 为 OFF &amp; Shift  键为 ON  → 大写英文字母<br>  CapsLock 为 为 ON &amp; Shift  键为 OFF  → 大写英文字母<br>  CapsLock 为 为 ON &amp; Shift  键为 ON  → 小写英文字母</p></blockquote><p>  在asmhead.nas中，我们已经从BIOS获取到了键盘的状态，保存到了binfo-&gt;leds中</p><blockquote><p>binfo-&gt;leds  的第 4  位 → ScrollLock  状态<br>  binfo-&gt;leds  的第 5  位  → NumLock  状态<br>  binfo-&gt;leds  的第 6  位  → CapsLock  状态</p></blockquote><p>  只要使用上述数据，我们就可以处理大小写字母的输入了。</p><p>  运行一下，效果如图<br>  <img src="/2019/05/21/30days-make-os/console5.png" alt></p></li><li><p>通过编码表，我们可以得到：</p><blockquote><p>0x3a: CapsLock<br>  0x45: NumLock<br>  0x46: ScrollLock</p></blockquote><p>  当我们接收到上述按键编码时，只要将binfo-&gt;leds中对应的位置改写就可以了。到这里我们已经实现了锁定键模式的切换，不过键盘上的指示灯却不会变化，下面是关于键盘指示灯的控制</p><blockquote><p> 关于LED的控制<br>   对于NumLock和CapsLock等LED的控制，可采用下面的方法向键盘发送指令和数据。<br>   读取状态寄存器，等待 bit 1的值变为 0。<br>   向数据输出（0060）写入要发送的 1个字节数据。<br>   等待键盘返回 1个字节的信息，这和等待键盘输入所采用的方法相同（用 IRQ等待或者用轮询状态寄存器 bit 1的值直到其变为 0都可以）。<br>    返回的信息如果为 0xfa，表明 1个字节的数据已成功发送给键盘。如为 0xfe则表明发送失败，需要返回第 1步重新发送。<br>    要控制LED的状态，需要按上述方法执行两次，向键盘发送EDxx数据。其中，xx的bit0代表ScrollLock，bit 1代表NumLock，bit 2代表CapsLock（0表示熄灭，1表示点亮）。bit 3～7为保留位，置0即可。</p></blockquote><p>  通过合理的编写程序就可以对键盘指示灯进行控制了。</p></li></ul><h2 id="第十八天"><a href="#第十八天" class="headerlink" title="第十八天"></a>第十八天</h2><ul><li>控制光标闪烁，将按下Tab键时的处理以及光标闪烁的处理改写了，当不想显示光标的时候，使cursor_c为负值。</li><li>使命令行窗口支持回车和滚动</li><li>命令行支持mem命令，用来显示内存使用情况；cls命令，清空屏幕内容；dir命令，显示文件信息。</li><li>以上除dir命令外涉及到的内容都不多，对于dir命令，要显示文件名信息，我们需要读取磁盘的内容，这得借助BIOS的帮助。在进入32位模式之前，我们已经从磁盘中读了10个柱面的内容。<blockquote><p>那么已经读出来的这些数据，存放在内存中的什么地方呢？在8.5节中写得很清楚，是 0x00100000～0x00267fff。其中存放文件名的地方又在哪里呢？其实我们也已经说过了，不过大家可能都不记得了吧，参考3.5节从0柱面、0磁头、1扇区开始的0x002600之后，也就是内存地址的0x00102600开始写入。</p></blockquote></li></ul><p>做个试验，在磁盘映像中加入haribote.sys、ipl10和make.bat三个文件。<br>磁盘映像中0x002600字节以后的部分，内容如下</p><pre><code>       +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF-------------------------------------------------------------------------002600 48 41 52 49 42 4F 54 45 53 59 53 20 00 00 00 00 HARIBOTESYS ....002610 00 00 00 00 00 00 18 74 FF 32 02 00 68 6B 00 00 .......t.2..hk..002620 49 50 4C 31 30 20 20 20 4E 41 53 20 00 00 00 00 IPL10 NAS ....002630 00 00 00 00 00 00 59 7A 42 41 38 00 95 0B 00 00 ......YzB58.....002640 4D 41 4B 45 20 20 20 20 42 41 54 20 00 00 00 00 MAKE BAT ....002650 00 00 00 00 00 00 F6 10 81 30 3E 00 2E 00 00 00 .........0&gt;.....002660 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code></pre><p>这里的内容是以32字节为单位循环的，这32个字节的结构如下</p><pre><code class="c">struct FILEINFO {    unsigned char name[8], ext[3], type;    char reserve[10];    unsigned short time, date, clustno;    unsigned int size;};</code></pre><p>开始的8个字节是文件名，文件名不足8个字节时用空格补足，如果文件名的第一个字节为0xe5，代表这个文件已经被删除了；文件名第一个字节为0x00，代表这一段不包含任何文件名信息。接下来的3个字节是扩展名，和文件名一样不足3个字节时用空格不足。后面1个字节存放文件的属性信息，一般的文件不是0x20就是0x00。</p><p>属性信息说明如下</p><pre><code>0x01······只读文件（不可写入）0x02······隐藏文件0x04······系统文件0x08······非文件信息（比如磁盘名称等）0x10······目录</code></pre><p>当一个文件既是只读文件又是隐藏文件时，将上面的对应值加算即可，即0x03。<br>接下来的10个字节为保留，下面2个字节为WORD整数，存放文件的时间。接下来的2个字节也是WORD整数，代表这个文件的内容从磁盘上的哪个扇区开始存放，是簇号（cluster number），最后的4个字节为DWORD整数，存放文件的大小。</p><p>执行一下我们写好的命令，结果如图<br><img src="/2019/05/21/30days-make-os/cmd1.png" alt><br><img src="/2019/05/21/30days-make-os/cmd2.png" alt><br><img src="/2019/05/21/30days-make-os/cmd3.png" alt></p><h2 id="第十九天"><a href="#第十九天" class="headerlink" title="第十九天"></a>第十九天</h2><ul><li>实现type命令，首先我们有一个公式 <strong>磁盘映像中的地址 = clustno * 512 + 0x003e00</strong>，有了这个公式就可以找到文件存放的位置，接下来只要将文件的内容逐字节读取出来并显示在屏幕上就可以了。在输出时，要注意对制表符，换行符和回车符的处理，否则输出就会错位。特殊字符编码如下<pre><code>0x09 ……制表符：显示空格直到 x  被 4  整除为止0x0a ……换行符：换行0x0d ……回车符：忽略</code></pre></li><li><p>对FAT的支持，按照Windows管理磁盘的方法，保存大于512字节的文件时，有时候并不是存入连续的扇区中。对于文件的下一段存放在哪里，磁盘是有记录的，这个记录存储在从0柱面、0磁头、2扇区开始的9个扇区中，在磁盘映像中相当于0x000200 ~ 0x0013ff，这个记录被称为FAT（file allocation table）。不过FAT使用了微软的算法进行压缩，需要用下面的方法进行解压缩</p><p>  F0 FF FF → FF0 FFF<br>  ab cd ef → dab efc</p></li></ul><pre><code>       +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF-----------------------------------------------------------------------000200 F0 FF FF 03 40 00 05 60 00 70 80 00 09 A0 00 0B ....@..`........000210 C0 00 0D E0 00 0F 00 01 11 20 01 13 40 01 15 60 ......... ..@..`000220 01 17 80 01 19 A0 01 1B C0 01 1D E0 01 1F 00 02 ................000230 21 20 02 23 40 02 25 60 02 27 80 02 29 A0 02 2B .......&amp;.29.....000240 C0 02 2D E0 02 2F 00 03 31 20 03 33 40 03 35 60 ..-../..1 .3@5.`000250 03 37 80 03 39 F0 FF 3B C0 03 3D E0 03 3F F0 FF .7..9..;..=..?..000260 FF 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................000270 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code></pre><p>对上面的FAT进行解压缩的话就会得到如下的数据</p><pre><code>    +0  +1  +2  +3  +4  +5  +6  +7  +8  +9------------------------------------------ 0 FF0 FFF 003 004 005 006 007 008 009 00A10 00B 00C 00D 00E 00F 010 011 012 013 01420 015 016 017 018 019 01A 01B 01C 01D 01E30 01F 020 021 022 023 024 025 026 027 02840 029 02A 02B 02C 02D 02E 02F 030 031 03250 033 034 035 036 037 038 039 FFF 03B 03C60 03D 03E 03F FFF FFF 000 000 000 000 000</code></pre><p>以haribote.sys为例，已知clustno = 2，因此读取0x004200 ~ 0x0045ff这512个字节，接下来看FAT的第2号记录，其值为003，也就是说下面的部分存放在clustno = 3这个位置，以此类推，我们一直读取到clustno = 57，而在FAT的第57号记录中存储的是FF<br>F，也就是说57号之后已经没有数据了，即这里就是文件的末尾。<strong>一般来说，如果遇到FF8 ~ FFF的值，就代表文件数据到此结束</strong>。</p><p>由于FAT文件非常重要，微软在磁盘中存放了2份FAT，第一份位于0x000200 ~ 0x0013ff，第二份位于0x001400 ~ 0x0025ff，其中第二份是备份，内容与第一份完全相同。</p><ul><li>整理一下bootpack.h开始写第一个应用程序<pre><code class="x86asm">[BITS 32]  CLIfin:  HLT  JMP fin</code></pre>将上面这段代码保存为hlt.nas，然后用nask进行汇编，生成hlt.hrb。这个扩展名hrb就相当于Windows下的exe。将文件的内容读到内存，我们为其创建一个内存段，接下来只要goto到该段中的程序，程序就会开始运行了。</li></ul><h2 id="第二十天"><a href="#第二十天" class="headerlink" title="第二十天"></a>第二十天</h2><ul><li>实现API<br><img src="/2019/05/21/30days-make-os/api.png" alt><br>在应用程序对API执行CALL的时候，要使用far-CALL，如下<pre><code class="x86asm">CALL    2*8:0xbe3</code></pre>因此返回的时候必须使用相应的far-RET，即RETF指令<pre><code class="x86asm">_asm_cons_putchar:  （中略）      RETF ; 这里！</code></pre></li><li>可是如果我们修改了操作系统的代码，_asm_cons_putchar的地址会随着改变，这样我们的应用程序也要重写，这显然是不现实的。IDT中最多可以设置256个函数，IRQ使用了16个，CPU用于通知异常状态的中断最多也只有32种，因此还剩下很多没有使用的项，所以我们就从IDT中找一个空闲的项用一下，我们就选0x40号（0x30 ~ 0xff均可），并将_asm_cons_putchar注册在这里。这样用INT 0x40就可代替原来的地址调用，返回指令也要相应的改成IRETD。用INT调用时，对于CPU来说相当于执行了中断处理程序，因此在调用的同时CPU会自动执行CLI指令来禁止中断请求，但我们并不需要禁止中断，因此需要在开头添加一条STI指令。</li><li>增加两个用于显示字符串的API，如果一直用之前的方式将他们设置为中断函数的话256个项目的IDT很快就会被用光。这里借鉴BIOS的调用方式，在寄存器中存入功能号，用EDX来存放功能号，就可以设置最多达42亿个API函数。<pre><code>功能号 1……显示单个字符（AL = 字符编码）  功能号 2……显示字符串 0（EBX = 字符串地址）  功能号 3……显示字符串 1（EBX = 字符串地址，ECX = 字符串长度）</code></pre>改写_asm_cons_putchar<pre><code class="x86asm">_asm_hrb_api:      STI      PUSHAD ; 用于保存寄存器值的PUSH      PUSHAD ; 用于向hrb_api传值的PUSH      CALL _hrb_api      ADD ESP,32      POPAD      IRETD</code></pre>用C语言编写的API处理程序如下<pre><code class="c">void hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax){  struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);  if (edx == 1) {      cons_putchar(cons, eax &amp; 0xff, 1);  } else if (edx == 2) {      cons_putstr0(cons, (char *) ebx);  } else if (edx == 3) {      cons_putstr1(cons, (char *) ebx, ecx);  }  return;}</code></pre></li></ul><h2 id="第二十一天"><a href="#第二十一天" class="headerlink" title="第二十一天"></a>第二十一天</h2><ul><li>在显示单个字符时，我们用[CS:ECX]的方式特意指定了CS，因此可以成功读取msg的内容，但在显示字符串时，由于无法指定段地址，程序误以为是DS而从完全错误的内存地址中读取了内容，所以显示就会出错。hrb_api并不知道代码段的起始位置位于内存的哪个地址，但cmd_app应该知道，因为代码段是由cmd_app设置。由于没有办法从cmd_app向hrb_api直接传递数据，所以我们像之前保存cons的地址一样，将它放在0xfe8，然后用类似与<strong>cons_putstr0(cons, (char *) ebx + cs_base);</strong>这样的调用方法就能正确读取内容了。</li><li>我们希望做到用C语言编写应用程序，例如<br><code>`</code>c<br>a.c</li></ul><p>void api_putchar(int c);<br>void HariMain(void)<br>{<br>    api_putchar(‘A’);<br>    return;<br>}</p><pre><code>api_putchar函数，需要用汇编语言编写，功能是向EDX和AL赋值，并调用INT 0x40，```x86asma_nask.nas[FORMAT &quot;WCOFF&quot;] ; 生成对象文件的模式[INSTRSET &quot;i486p&quot;] ; 表示使用486兼容指令集[BITS 32] ; 生成32位模式机器语言[FILE &quot;a_nask.nas&quot;] ; 源文件名信息            GLOBAL _api_putchar[SECTION .text]_api_putchar:   ; void api_putchar(int c);        MOV     EDX,1        MOV     AL,[ESP+4] ; c        INT     0x40        RET</code></pre><p>这里的api_putchar需要与a.c的编译结果进行连接。</p><p>不过这样生成的hrb还是不能运行，我们需要将a.hrb开头的6个字节替换成“E8 16 00 00 00 CB”。这六个字节就相当于下面三行代码汇编之后的结果</p><pre><code class="x86asm">[BITS 32]        CALL 0x1b        ETF</code></pre><p>也就是先调用0x1b这个地址的函数，从函数返回后再执行far-RET，这里的0x1b就是.hrb文件中HariMain的地址。</p><p>添加如下的代码就可让我们在读取数据到内存中时，先修改前六个字节再运行</p><pre><code class="c">if (finfo-&gt;size &gt;= 8 &amp;&amp; strncmp(p + 4, &quot;Hari&quot;, 4) == 0) { /*从此开始*/    p[0] = 0xe8;    p[1] = 0x16;    p[2] = 0x00;    p[3] = 0x00;    p[4] = 0x00;    p[5] = 0xcb;} /*到此结束*/</code></pre><ul><li>保护操作系统，有一些电脑病毒或恶意软件，或者是应用程序的bug，可能会对操作系统造成破坏，造成死机等情况，所以我们需要操作系统的保护机制。</li></ul><p>例如</p><pre><code class="c">void HariMain(void){    *((char *) 0x00102600) = 0;    return;}</code></pre><p>上述程序擅自访问了本该由操作系统来管理的内存空间，对于这种情况，我们需要为应用程序提供专用的内存空间，要做到这一点，我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。</p><pre><code>操作系统用代码段……2 * 8操作系统用数据段……1 * 8应用程序用代码段……1003 * 8应用程序用数据段……1004 * 8（3 * 8～1002 * 8为TSS所使用的段）</code></pre><p>接着作者写了很多用于段切换的函数，看的云里雾里的，结果到最后说CPU其实提供了这种进行段切换的功能，无需我们自己去写。</p><ul><li>接下来实现强制结束程序，只要在中断号0x0d中注册一个函数即可，因为在x86架构规范中，当应用程序试图破坏操作系统时或者试图违背操作系统的设置时，就会自动产生0x0d中断，因此该中断也被称为“异常”。</li><li>操作系统会指定应用程序用的DS，因此破坏行为会发生异常，那么如果应用程序忽略操作系统指定的DS，用汇编语言直接将操作系统用的段地址存入DS的话，就可以破坏操作系统。我们要对这种情况进行处理，在段定义的地方，如果将访问权限加上0x60的话，就可以将段设置为应用程序用，当CS中的段地址为应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。如果使用这样的方法，就必须在TSS中注册操作系统用的段地址和ESP，这样才能实现内核态和用户态之间的切换，我们自己写的段切换也就不需要了。IDT中的INT 0x40的访问权限也要加上0x60，让它成为“可供应用程序作为API调用的中断”。</li></ul><h2 id="第二十二天"><a href="#第二十二天" class="headerlink" title="第二十二天"></a>第二十二天</h2><ul><li><p>经过我们之前的一番设置，操作系统得到了很好的保护，一般的攻击手段已经不起作用了。</p><p>  在操作系统的内存空间里搞破坏行不通了，在定时器上动手脚呢？</p><pre><code class="x86asm">[INSTRSET &quot;i486p&quot;][BITS 32]      MOV AL,0x34      OUT 0x43,AL      MOV AL,0xff      OUT 0x40,AL      MOV AL,0xff      OUT 0x40,AL; 上述代码的功能与下面代码相当; io_out8(PIT_CTRL, 0x34);; io_out8(PIT_CNT0, 0xff);; io_out8(PIT_CNT0, 0xff);      MOV EDX,4      INT 0x40</code></pre><p>然而上述代码并不会对我们的操作系统造成破坏，当以应用模式运行时，执行IN指令和OUT指令都会产生一般保护异常。</p></li></ul><p>如果执行CLI再HLT呢？</p><pre><code class="x86asm">[INSTRSET &quot;i486p&quot;][BITS 32]        CLIfin:        HLT        JMP     fin</code></pre><p>依旧不能破坏系统，当以应用程序模式运行时，执行CLI、STI和HLT这些指令都会产生异常。</p><p>操作系统里有一个用来CLI的函数，far-CALL这个函数呢？</p><pre><code class="x86asm">[INSTRSET &quot;i486p&quot;][BITS 32]        CALL 2*8:0xac1        MOV EDX,4        INT 0x40</code></pre><p>还是不能对操作系统进行破坏，如果应用程序可以CALL任意地址的话，像这样就能破坏操作系统了，因此CPU规定除了设置好的地址以外，禁止应用程序CALL其他的地址。</p><p>但是如果我们对API进行修改的话还是可以破坏操作系统的，如果操作系统内部的API本身就有BUG，那我们用户就无能为力了，想要防止这种问题的发生，我们只能“不安装不可靠的操作系统”了。</p><ul><li><p>帮助发现BUG<br>  如果我们写出了有bug的代码，如</p><pre><code class="c">  void api_putchar(int c);  void api_end(void);  void HariMain(void)  {      char a[100];      a[10] = &#39;A&#39;; /*这句当然没有问题*/      api_putchar(a[10]);      a[102] = &#39;B&#39;; /*这句就有问题了*/      api_putchar(a[102]);      a[123] = &#39;C&#39;; /*这句也有问题了*/      api_putchar(a[123]);      api_end();  }  `</code></pre><p>  由于a是保存在栈中的，因此这次会产生栈异常。我们需要一个函数来处理栈异常，栈异常的中断号为0x0c。PS：根据CPU说明书，从0x00到0x1f都是异常所使用的中断。仿照inthandler0d函数，编写inthandler0c函数，然后将其注册到IDT中。在真机环境下，显示出“AB”之后才产生异常，为什么写入“B”不会产生异常呢？是因为虽然a[102]超出了数组的边界，但却没有超出为应用程序分配的数据段边界，而a[123]所在的地址已经超出了数据段的边界，因此写入“C”会产生异常。</p><p>  在异常处理程序中，加入如下代码</p><pre><code class="c">  sprintf(s, &quot;EIP = %08X\n&quot;, esp[11]);  cons_putstr0(cons, s);</code></pre><p>  其功能是，将esp的11号元素（即EIP）显示出来，这样我们就能知道引发异常的指令的地址。</p><p>  其他元素有</p><pre><code class="x86asm">  esp[ 0] : EDI  esp[ 1] : ESI esp[0 ～7] 为_asm_inthandler 中PUSHAD 的结果  esp[ 2] : EBP  esp[ 4] : EBX  esp[ 5] : EDX  esp[ 6] : ECX  esp[ 7] : EAX  esp[ 8] : DS esp[8 ～9] 为_asm_inthandler 中PUSH 的结果  esp[ 9] : ES  esp[10] : 错误编号（基本上是0，显示出来也没什么意思）  esp[11] : EIP  esp[12] : CS esp[10 ～15] 为异常产生时CPU 自动PUSH 的结果  esp[13] : EFLAGS  esp[14] : ESP （应用程序用ESP ）  esp[15] : SS （应用程序用SS</code></pre></li><li><p>强制结束应用程序</p><p>  如果我们运行一个，类似于下面这样的程序</p><pre><code class="c">void HariMain(void){  for (;;) { }}</code></pre><p>它将永远循环下去而无法结束，中断并没有被禁用，因此其他的任务还可以照常工作，不过这个任务总归要消耗一定的CPU运行时间，系统整体的速度就会变慢，因此我们需要强制结束应用程序的方法。</p></li></ul><pre><code class="C">if (i == 256 + 0x3b &amp;&amp; key_shift != 0 &amp;&amp; task_cons-&gt;tss.ss0 != 0) { /* Shift+F1 */    cons = (struct CONSOLE *) *((int *) 0x0fec);    cons_putstr0(cons, &quot;\nBreak(key):\n&quot;);    io_cli(); /*不能在改变寄存器值时切换到其他任务*/    task_cons-&gt;tss.eax = (int) &amp;(task_cons-&gt;tss.esp0);    task_cons-&gt;tss.eip = (int) asm_end_app;    io_sti();</code></pre><p>上述程序的工作原理是，当按下强制结束键（shift + F1）时，改写命令行窗口任务的的寄存器值，并goto到asm_end_app。</p><pre><code class="c">_asm_end_app:; EAX为tss.esp0的地址        MOV ESP,[EAX]        MOV DWORD [EAX+4],0 ; 这里！        POPAD        RET ; 返回cmd_app</code></pre><p>这样一来程序会被强制结束，但也有个问题，那就是当应用程序没有在运行的时候，按下强制结束键会发生误操作。所以我们必须要确认task_cons-&gt;tss.ss0不为0时才能继续进行处理。我们还得进行一些修改，使得当应用程序运行时，该值一定不为0；而当应用程序没有运行时，该值一定为0，为此，我们在在task_alloc加入<code>task-&gt;tss.ss0 = 0;</code>。</p><ul><li>我们写好了显示字符串的API，然后要写一个C语言调用该API的函数，如下<pre><code>_api_putstr0: ; void api_putstr0(char *s);      PUSH EBX      MOV EDX,2      MOV EBX,[ESP+8] ; s      INT 0x40      POP EBX      RET</code></pre>但是我们在程序中使用该函数的时候，却不能显示字符。这是为什么呢?</li></ul><p>在API函数中，显示字符串时需要字符串的首地址，若应用程序是通过bim2hrb生成的话，程序还会链接obj文件，生成的hrb文件分为两个部分——代码部分和数据部分。不过我们之前一直没有考虑数据部分，当程序中没有字符串和外部变量时，就会生成不含数据部分的hrb文件，因此之前的程序都不会出现问题。</p><p>.hrb文件的数据部分会在应用程序启动时被传送到应用程序用的数据段中，而.hrb文件中数据部分的位置则存放在代码部分的开头一块区域中，由bim2hrb生成的.hrb文件，开头的36个字节不是程序，而是存放了下列这些信息</p><pre><code>0x0000 (DWORD)  …… 请求操作系统为应用程序准备的数据段的大小0x0004 (DWORD)  …… “Hari”（.hrb 文件的标记）0x0008 (DWORD)  …… 数据段内预备空间的大小0x000c (DWORD)  …… ESP 初始值&amp; 数据部分传送目的地址0x0010 (DWORD)  …… hrb 文件内数据部分的大小0x0014 (DWORD)  …… hrb 文件内数据部分从哪里开始0x0018 (DWORD)  …… 0xe90000000x001c (DWORD)  …… 应用程序运行入口地址 - 0x200x0020 (DWORD)  …… malloc空间的起始地址</code></pre><p>E9是JMP指令的机器码，跳转的偏移地址为应用程序入口地址 - 0x20。</p><p>当启动应用程序时，操作系统为应用程序分配了代码段和数据段，启动前应该先将hrb文件中的数据复制到数据段再执行应用程序。</p><ul><li>显示窗口/在窗口中描绘字符和方块，操作系统已经有了显示窗口以及显示字符和方块的函数，可以在hrb_api中调用，只需要确定一下功能号并且正确传参即可实现显示窗口以及在窗口上显示文字的功能。</li></ul><h2 id="第二十三天"><a href="#第二十三天" class="headerlink" title="第二十三天"></a>第二十三天</h2><ul><li>编写malloc函数，我们已经有了一个memman_alloc函数，但是因为memman_alloc函数分配的内存空间并不位于应用程序的数据段范围内，所以我们需要编写一个为应用程序分配内存空间的API函数，然后将malloc的内存空间首地址写到hrb文件中去，这样可以有效减小hrb文件的大小。</li></ul><p>malloc函数要想实现分配内存的功能，那么操作系统就需要提前给应用程序预留一定大小的空间用于malloc，因为应用程序所需要的内存空间不好预测，最好的做法是用于给malloc分配的内存空间可以调整大小，但是在我们自制的操作系统中暂时没有实现这样的功能，只能给malloc函数预留一定大小的空间，这应该是一个需要优化的地方。实现malloc函数的同时，我们当然也要实现一个free函数</p><p>编写API函数malloc和free的思路：  </p><ol><li>使用memman_init函数初始化一个memman，参数中的地址要写应用程序段的地址</li><li>使用memman_free函数释放空间，为应用程序的malloc预留这段空间</li><li>使用memman_alloc函数可以为应用程序分配空间</li><li>使用memman_free函数可以释放分配的内存空间</li></ol><ul><li>画点/画线，想要在任务的界面上显示一些内容，只需要在对应图层的buf中填写相应的内容，然后刷新图层即可。之前的图层SHEET定义如下：<pre><code class="c">struct SHEET{  unsigned char *buf;  /*用来记录图层上所描画内容的地址*/  int xsize,ysize,x,y,color,height,flags;  struct SHTCTL *ctl;    };</code></pre></li></ul><ol><li>若要在窗口上显示一个点，那么就在对应图层的buf中修改一个单元的内容即可。</li><li>若要在窗口上显示多个点，那么就在对应图层的buf中修改多个单元的内容即可。</li><li>可以画点就可以画线，只要确定了线的起点坐标和终点坐标，就可以画出这条线。</li></ol><p>画线方法：</p><p>设起点（x0，y0），终点（x1，y1）</p><ol><li>求横纵坐标差值的绝对值：dx = |x1 - x0|，dy = |y1 - y0|</li><li><p>比较dx和dy，确定点的个数len：  </p><pre><code> a. 若dx &gt;= dy, len = dx + 1, dx = 1, dy = dy / len, 若x0 &lt; x1, dy = -dy, 若y0 &lt; y1, dy = -dy b. 若dx &lt; dy, len = dy + 1, dy = 1, dx = dx / len, 若x0 &lt; x1, dx = -dx, 若y0 &lt; y1, dy = -dy</code></pre></li><li><p>x = x0, y = y0</p><pre><code> 按如下方式画len个点：   画点（x，y），x += dx, y += dy</code></pre></li></ol><ul><li>现在我们可以在窗口上画点、画线了，不过一个问题出现了，在应用程序结束之后，窗口依然还留在画面上。这是因为系统为留在画面上的这个窗口分配了应用程序的数据段作为存放窗口图层的内存空间，当应用程序活动时没有任何问题，但当应用程序运行结束后，其数据段的内存空间就被释放出来，供操作系统及其他应用程序来使用，所以这样不行。在应用程序结束之前，我们需要先关闭窗口。该功能的实现也很简单，我们只需要在API函数api_closewin中调用sheet_free函数即可。</li><li>想要实现按下某个按键关闭窗口的功能，我们需要API实现函数get_key，其返回值为按键编码。我们通过循环不断从FIFO中取出数据直到FIFO为空或成功接收到键盘输入后循环结束，在此过程中FIFO还会收到诸如计时器光标ON、OFF之类的数据，我们需要简单地将它们处理掉。为了设置定时器，我们需要timer的地址，不过这是console_task中的变量，hrb_api是无法获取的，所以我们将定时器加入到struct CONSOLE中了，因为这个定时器是用来控制光标闪烁的，对于命令行窗口来说是必需的。这里的键盘输入API提供了阻塞和非阻塞两种方式，如果是非阻塞，则当FIFO为空时立即返回-1；如果是阻塞，则当FIFO为空时任务休眠并等待。</li><li>如果我们按Shift + F1强制结束程序的话，窗口还是会残留在界面上，所以我们在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序，则关闭该图层。</li></ul><h2 id="第二十四天"><a href="#第二十四天" class="headerlink" title="第二十四天"></a>第二十四天</h2><ul><li>首先实现用键盘鼠标切换窗口、用鼠标移动窗口和用鼠标关闭窗口的功能，这几个功能实现起来很简单。我们使用按键F11来作为窗口切换的按键，按下F11，我们就将从下面数第2个图层的高度提升为shtctl-&gt;top-1，shtctl-&gt;top这个高度存放的是最上面一个图层的高度，这个图层永远是绘制鼠标用的。使用鼠标切换时，我们按照图层从上到下的顺序寻找鼠标所指向的图层，最先找到的图层就是鼠标指向的图层，找到之后，将该图层的高度提升为shtctl-&gt;top-1。窗口移动是基于鼠标移动进行的，当鼠标按下鼠标左键时，鼠标位于所选中图层的标题栏，那么此时该图层跟随鼠标一起移动。只要记录下鼠标移动的横坐标以及纵坐标，就可以计算出其移动的距离，图层也移动同样的距离即可。<br>对于用鼠标关闭窗口的功能，只要判断鼠标按下时其坐标是否是在“X”按钮上，就可以实现。</li><li>虽然我们已经实现了让应用程序接受键盘输入的功能，不过仔细看画面发现，处于输入状态的其实是命令行窗口，我们想要让应用程序处于输入状态。之前我们所使用的Tab键切换很简单，只能在两个窗口之间交替进行，但是现在我们有3个以上的窗口，我们这样规定，按下Tab键时将键盘输入切换到当前输入窗口下面一层的窗口中，若当前窗口为最下层则切换到最上层窗口。当应用程序窗口处于输入模式时被关闭，我们让系统自动切换到最上层的窗口。<br>我们用SHEET结构中的task成员来判断数据发送对象的FIFO，因此在sht_cons-&gt;task中也加入了TASK结构的地址，这样的话我们就无法分辨窗口是不是由应用程序生成的，于是我们需要通过SHEET结构中的flags成员的0x10比特位来分辨窗口是不是由应用程序生成的，当该比特位为1时，表示该窗口是应用程序窗口；使用SHEET结构中的flags成员的0x20比特位来分辨该窗口是否需要光标控制。</li><li>刚才为了实现用Tab键切换，我们修改了很多代码，这次我们只需要添加一点点代码就可以实现用鼠标切换输入窗口了，如下<pre><code class="c">if (sht != key_win) {      cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x);      key_win = sht;      cursor_c = keywin_on(key_win, sht_win, cursor_c);}</code></pre></li><li>关于定时器的部分，操作系统已经实现了定时器的功能，但是应用程序没有办法使用，我们可以使用API的方式使得应用程序也可以使用定时器。首先我们需要确定关于定时器操作的API的功能号以及参数，然后按照以前编写API的方式编写API。要注意应用程序结束之后一定要取消应用程序中的定时器，要不然该定时器就会给命令行本身发送数据，而命令行本身肯定是一头雾水。</li></ul><h2 id="第二十五天"><a href="#第二十五天" class="headerlink" title="第二十五天"></a>第二十五天</h2><p>增加蜂鸣器发声的功能</p><ul><li><p>蜂鸣器的发声和定时器一样，是由PIT来控制的</p><blockquote><p>  蜂鸣器发声的控制<br>　　  音高操作<br>　　  AL = 0xb6; OUT(0x43, AL);<br>　　  AL = 设定值的低位 8bit; OUT(0x42, AL);<br>　　  AL = 设定值的高位 8bit; OUT(0x42, AL);<br>　　  设定值为 0时当作 65536来处理。<br>　　  发声的音高为时钟除以设定值，也就是说设定值为 1000时相当于发出 1.19318KHz的声音；设定值为 10000时相当于 119.318Hz。因此设定 2712即可发出约 440Hz的声音<br>  蜂鸣器ON/OFF<br>　　  使用 I/O端口 0x61控制。<br>　　  ON：IN(AL, 0x61); AL |= 0x03; AL &amp;= 0x0f; OUT(0x61, AL);<br>　　  OFF：IN(AL, 0x61); AL &amp;= 0xd; OUT(0x61, AL);</p></blockquote></li><li><p>这里的时钟是PIT时钟而不是CPU时钟，频率恒定为1.19318MHz。API设计如下</p><blockquote><p>蜂鸣器发声<br>EDX=20<br>EAX=声音频率（单位是mHz，即毫赫兹）<br>例如当EAX=4400000时，则发出440Hz的声音<br>频率设为0则表示停止发声</p></blockquote></li><li><p>程序的编写很简单，不过遗憾的是我们用的模拟器并没有模拟蜂鸣器发声的功能</p></li><li><p>到目前为止，我们的操作系统只用了16种颜色，但我们已经用上了256色的显示模式，还有240种颜色可以用，所以我们要修改一下操作系统，增加可以显示的颜色。为三原色中每种颜色赋予6个色阶，这样就可以定义出216种颜色，没定义的就只剩下24种颜色了，不过这样会产生8种重复的颜色，编写程序显示效果如下<br><img src="/2019/05/21/30days-make-os/color.png" alt></p></li><li><p>我们还有一种方式可以让颜色变得更加丰富，使用颜色交替排列的方式，将两种颜色混合在一起，混合方式有3种，这样虽然只有6级色阶，但却可以显示出21阶色阶<br><img src="/2019/05/21/30days-make-os/mix.png" alt></p></li><li><p>显示效果更加平滑<br><img src="/2019/05/21/30days-make-os/color2.png" alt></p></li><li><p>迄今为止我们还不能实现同时启动两个以上的应用程序，如果修改命令行窗口使其在应用程序运行中就可以输入下一条命令的修改量太大，所以作者打算同时启动两个命令行窗口，同时删掉task_a，这样我们的操作系统更像一个真正的操作系统了<br><img src="/2019/05/21/30days-make-os/morelikerealos.png" alt></p></li></ul><h2 id="第二十六天"><a href="#第二十六天" class="headerlink" title="第二十六天"></a>第二十六天</h2><ul><li><p>窗口移动的速度很慢，所以打算对窗口移动进行提速。窗口移动慢的原因之一就是sheet_refreshmap的速度太慢。此函数中有如下语句</p><pre><code class="c">for (by = by0; by &lt; by1; by++) {  vy = sht-&gt;vy0 + by;  for (bx = bx0; bx &lt; bx1; bx++) {      vx = sht-&gt;vx0 + bx;      if (buf[by * sht-&gt;bxsize + bx] != sht-&gt;col_inv) {          map[vy * ctl-&gt;xsize + vx] = sid;      }  }}</code></pre><p>其中的if语句位于三层for循环中被执行了很多次，因此如果能去掉这个if语句的话，速度应该会有不小的提高。</p></li><li><p>这个if语句的功能是判断图层是否为透明部分，如果强行去掉它鼠标指针就会变成一个方块，不过我们的窗口基本都是矩形的，没有透明部分，如果仅去掉窗口部分的if判断是没有影响的。所以我们将程序修改成如下的样子</p><pre><code class="c">if (sht-&gt;col_inv == -1) {  /*无透明色图层专用的高速版*/  for (by = by0; by &lt; by1; by++) {      vy = sht-&gt;vy0 + by;      for (bx = bx0; bx &lt; bx1; bx++) {          vx = sht-&gt;vx0 + bx;          map[vy * ctl-&gt;xsize + vx] = sid;      }  }} else {  /*有透明色图层用的普通版*/  for (by = by0; by &lt; by1; by++) {      vy = sht-&gt;vy0 + by;      for (bx = bx0; bx &lt; bx1; bx++) {          vx = sht-&gt;vx0 + bx;          if (buf[by * sht-&gt;bxsize + bx] != sht-&gt;col_inv) {              map[vy * ctl-&gt;xsize + vx] = sid;          }      }  }}</code></pre></li><li><p>在sheet_refreshmap中有这样一句</p><pre><code class="c">map[vy * ctl-&gt;xsize + vx] = sid;</code></pre><p>这个命令的功能是向内存中某个地址写入sid的值，它也位于for循环中会被反复执行，而且这个地址后面以及再后面的地址也要写入sid的值。在汇编语言中，如果我们用32位寄存器来执行MOV指令的话，仅一条指令就可以向相邻的4个地址写入值，只要指定地址是4的整数倍，指令的执行速度就和一个字节的MOV是相同的，也就是说速度可以提高4倍。因此，为了让这次的修改发挥最大的效果，我们需要使窗口在x方向上的大小为4的倍数，而且窗口的x坐标也要为4的倍数，目前所有的窗口大小都是4的倍数，所以不需要修改，而对于窗口坐标，我们需要做AND运算来取整，使打开窗口时的显示位置为4的倍数，使用鼠标拖动窗口时的目的地坐标保证是4的倍数。一次性写入4个字节的办法可以有效地提高速度，所以其它函数中的有关语句我们也可以修改，例如sheet_refreshsub。</p></li><li><p>窗口移动的速度变快了，但是还是跟不上鼠标的移动速度，在放开鼠标键之后窗口还在移动。这是因为伴随图层移动所进行的绘图错做非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据，所以我们等FIFO为空时再进行绘图操作。</p></li><li><p>添加使用Shift+F2启动命令行窗口的功能，同时我们增加可以启动多个命令行窗口的功能。</p></li><li><p>我们实现了开启多个命令行窗口的功能，自然而然的我们就要实现关闭命令行窗口的功能。</p></li><li><p>增加两个新的命令start（打开一个新的命令行窗口并运行指定的应用程序）和ncst（不打开新的命令行窗口而运行指定的应用程序）。</p></li></ul><h2 id="第二十七天"><a href="#第二十七天" class="headerlink" title="第二十七天"></a>第二十七天</h2><ul><li>继续修补小细节，实现在启动应用程序后可以关闭命令行窗口的功能。</li><li>现在我们可以阻止应用程序访问操作系统用的段，但是一个应用程序访问其他应用程序的段，所以我们要使用LDT（local descriptor table）。我们通过GDTR寄存器将GDT的内存地址告知CPU，而LDT的内存地址则是通过在GDT中创建LDT段来告知CPU的。</li><li>由于创建应用程序时所引用的a_nask.nas变大了，在应用程序中我们没有使用的函数也被包含了进去。因此我们选择将函数拆开，从而在链接阶段，只将每个应用程序必需的.obj文件链接上去，这样可以有效减小应用程序的大小。</li><li>但是拆开会产生过多的.obj文件，想要解决这个问题，我们可以使用“库”，通过作者提供的库管理器，我们可以将.obj打包成一个.lib文件，这样文件的数量就减少了</li><li>最后就是整理Makefile使其更精简整洁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 30天自制操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
            <tag> c </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,World</title>
      <link href="/2019/05/21/Hello-World/"/>
      <url>/2019/05/21/Hello-World/</url>
      
        <content type="html"><![CDATA[<p>不止一次，想找个地方记录一下自己想法，记一下学习笔记。可是懒得搞博客，主要是找不到好看的主题，而且总想搞得完美一点儿，所以就一直拖着。最近又把这个烂摊子捡起来，找到个还算能看的主题，先上线再迭代吧:)</p><pre><code class="c">int main(){    printf(&quot;Hello,world!\n&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
